#!/bin/env ruby
#
# $File$
# $DateTime$
#
# $Revision$
# $Author$
#
# 2012 Vmware Zimbra
#
# DKIM signature multidomain case
#

if($0 == __FILE__)
  mydata = File.expand_path(__FILE__).reverse.sub(/.*?atad/,"").reverse;$:.unshift(mydata); $:.unshift(File.join(mydata, 'src', 'ruby')) #append library path
end

require "model"
require "action/block" 
 
require "action/zmprov" 
require "action/sendmail" 
require "action/waitqueue"
require "action/zmdkimkeyutil"
require "action/decorator"
require "action/verify" 
require "action/zmprov"
require "action/decorator"
require "net/imap"; require "action/imap" #Patch Net::IMAP library

include Action
#Net::IMAP.debug=true

#
# Global variable declaration
#
current = Model::TestCase.instance()
current.description = "zmdkimkeyutil: multidomain case"

name = File.expand_path(__FILE__).sub(/.*?(data\/)(genesis\/)?(zm)?/, 'zm').sub('.rb', '').gsub(/\/|\(|\)/, '') + Time.now.to_i.to_s + "_1"
testAccount = Model::TARGETHOST.cUser(name, Model::DEFAULTPASSWORD)

domain2 = File.expand_path(__FILE__).sub(/.*?(data\/)(genesis\/)?(zm)?/, 'zm').sub('.rb', '').gsub(/\/|\(|\)/, '') + Time.now.to_i.to_s + "x2" + ".org"
domain3 = File.expand_path(__FILE__).sub(/.*?(data\/)(genesis\/)?(zm)?/, 'zm').sub('.rb', '').gsub(/\/|\(|\)/, '') + Time.now.to_i.to_s + "x3" + ".org"
name2 = name+"_2"
name3 = name+"_3"

mimap = d
mimap2 = d
mimap3 = d

message = <<EOF.gsub(/\n/, "\r\n")
Date: Fri, 23 Feb 2007 16:57:04 -0800
User-Agent: Thunderbird 1.5.0.9 (Windows/20061207)
Subject: testing DKIM 
Some messages for DKIM signature testing.

EOF

mselector2 = nil
mselector3 = "slt3_" + Time.now.to_i.to_s

run_on_mta = Model::Host.new(Model::Servers.getServersRunning("mta").first)
imap_host = Model::Servers.getServersRunning("proxy").first ||
            Model::Servers.getServersRunning("mailbox").first
     
#
# Setup
#
current.setup = [


]
#
# Execution
#
current.action = [
  ZMProv.new('cd', domain2),
  ZMProv.new('cd', domain3),
  CreateAccount.new(testAccount.name,testAccount.password),
  CreateAccount.new(name2 + '@' + domain2, Model::DEFAULTPASSWORD),
  CreateAccount.new(name3 + '@' + domain3, Model::DEFAULTPASSWORD),
  
  # do not add DKIM signature to default domain
  
  # add new DKIM signature to domain 2 and custom key size
  v(ZMDkimkeyutil.new("-a", "-d", domain2, "-b 2048", run_on_mta)) do |mcaller,data|
      mcaller.pass = data[0] = 0 &&
                     data[1].match("DKIM Data added to LDAP for domain #{domain2} with selector") &&
                     data[1].match("Public signature to enter into DNS:") &&
                     data[1].match(/Public signature to enter into DNS:.*_domainkey.*IN.*TXT.*v=DKIM1; k=rsa;.*p=.*;.*DKIM key .* for #{Regexp.quote(domain2)}/m)
      # catch randomly created UUID
      mselector2 = data[1].match(/with selector (.*)\n/)[1] if mcaller.pass
  end,
  # add new DKIM signature to domain 3 with custom selector
  v(ZMDkimkeyutil.new("-a", "-s", mselector3, "-d", domain3, run_on_mta)) do |mcaller,data|
      mcaller.pass = data[0] = 0 &&
                     data[1].match("DKIM Data added to LDAP for domain #{domain3} with selector #{mselector3}") &&
                     data[1].match("Public signature to enter into DNS:") &&
                     data[1].match(/^#{Regexp.quote(mselector3)}.*_domainkey.*IN.*TXT.*v=DKIM1; k=rsa;.*p=.*;.*DKIM key #{Regexp.quote(mselector3)} for #{Regexp.quote(domain3)}/m)
  end,
  
  # send message from domains with new signature
  # from user 2 to user 1
  Action::SendMail.new(testAccount.name, message, name2 + '@' + domain2, run_on_mta),
  # from user 3 to user 1
  Action::SendMail.new(name2 + '@' + domain2, message, name3 + '@' + domain3, run_on_mta),
  # from user1 to user2
  Action::SendMail.new(name3 + '@' + domain3, message, testAccount.name, run_on_mta),
  Action::WaitQueue.new(600, run_on_mta),
  
  # check the message from 2 to 1 is signed with autogenerated DKIM signature
  v(cb("Check message 1 headers") do
    result = []
    mimap.object = Net::IMAP.new(imap_host, *Model::TARGETHOST.imap)
    mimap.login(testAccount.name, testAccount.password)
    mimap.select("INBOX")
    result[0] = mimap.fetch(1, "BODY[HEADER.FIELDS (DKIM-SIGNATURE)]")[0][:attr]
    result[1] = mimap.fetch(1, "BODY[HEADER.FIELDS (AUTHENTICATION-RESULTS)]")[0][:attr]
    result[2] = mimap.fetch(1, "BODY[HEADER.FIELDS (DKIM-FILTER)]")[0][:attr]
    result
  end) do |mcaller, data|
    mcaller.pass = !data[0]["BODY[HEADER.FIELDS (DKIM-SIGNATURE)]"].chomp.empty? &&
                   !data[1]["BODY[HEADER.FIELDS (AUTHENTICATION-RESULTS)]"].chomp.empty? &&
                   !data[2]["BODY[HEADER.FIELDS (DKIM-FILTER)]"].chomp.empty? &&
                   data[0]["BODY[HEADER.FIELDS (DKIM-SIGNATURE)]"].match(/s=#{Regexp.quote(mselector2)};/)
  end,
  
  # check the message from 3 to 2 is signed with custom DKIM signature
  v(cb("Check message 2 headers") do
    result = []
    mimap2.object = Net::IMAP.new(imap_host, *Model::TARGETHOST.imap)
    mimap2.login(name2 + '@' + domain2, testAccount.password)
    mimap2.select("INBOX")
    result[0] = mimap2.fetch(1, "BODY[HEADER.FIELDS (DKIM-SIGNATURE)]")[0][:attr]
    result[1] = mimap2.fetch(1, "BODY[HEADER.FIELDS (AUTHENTICATION-RESULTS)]")[0][:attr]
    result[2] = mimap2.fetch(1, "BODY[HEADER.FIELDS (DKIM-FILTER)]")[0][:attr]
    result
  end) do |mcaller, data|
    mcaller.pass = !data[0]["BODY[HEADER.FIELDS (DKIM-SIGNATURE)]"].chomp.empty? &&
                   !data[1]["BODY[HEADER.FIELDS (AUTHENTICATION-RESULTS)]"].chomp.empty? &&
                   !data[2]["BODY[HEADER.FIELDS (DKIM-FILTER)]"].chomp.empty? &&
                   data[0]["BODY[HEADER.FIELDS (DKIM-SIGNATURE)]"].match(/s=#{Regexp.quote(mselector3)};/)
  end,
  
  # check the message from 1 to 3 is not signed
  v(cb("Check message 3 headers") do
    result = []
    mimap3.object = Net::IMAP.new(imap_host, *Model::TARGETHOST.imap)
    mimap3.login(name3 + '@' + domain3, testAccount.password)
    mimap3.select("INBOX")
    result[0] = mimap3.fetch(1, "BODY[HEADER.FIELDS (DKIM-SIGNATURE)]")[0][:attr]
    result[1] = mimap3.fetch(1, "BODY[HEADER.FIELDS (AUTHENTICATION-RESULTS)]")[0][:attr]
    result[2] = mimap3.fetch(1, "BODY[HEADER.FIELDS (DKIM-FILTER)]")[0][:attr]
    result
  end) do |mcaller, data|
    mcaller.pass = data[0]["BODY[HEADER.FIELDS (DKIM-SIGNATURE)]"].chomp.empty? &&
                   data[1]["BODY[HEADER.FIELDS (AUTHENTICATION-RESULTS)]"].chomp.empty? &&
                   data[2]["BODY[HEADER.FIELDS (DKIM-FILTER)]"].chomp.empty?
  end,

  cb("Clean up mimap") do
    mimap.logout
    mimap.disconnect
    mimap2.logout
    mimap2.disconnect
    mimap3.logout
    mimap3.disconnect
  end
  
]

#
# Tear Down
#
current.teardown = [
  DeleteAccount.new(testAccount.name),
  DeleteAccount.new(name2 + '@' + domain2),
  DeleteAccount.new(name3 + '@' + domain3),
  ZMProv.new('dd', domain2),
  ZMProv.new('dd', domain3),
  
]

if($0 == __FILE__)
  require 'engine/simple'
  testCase = Model::TestCase.instance
  Engine::Simple.new(Model::TestCase.instance).run
end
