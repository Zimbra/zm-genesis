<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE stax SYSTEM "stax.dtd">
<stax>  
    <script>confirm = "Y\n"</script>
    <script>failed = "FAILED"</script>
    <script>passed = "PASSED"</script>
    <script>stopTimeout = "3m"</script>
    <script>configFile="/tmp/config.txt"</script>
    <script>STAXMessageLog=1</script>
    <script>bURL = "http://build.lab.zimbra.com:8000/links/RHEL4/BIRDSEYE_M2/20051220133623_NETWORK/ZimbraBuild/i386/"</script>

    <function name="endOfJob" scope="local">
        <function-prolog>
            This function is used to notify termination of a job
        </function-prolog>
        <function-map-args>
            <function-required-arg name="jobId">
                Job ID
            </function-required-arg>
            <function-optional-arg name="outputFile" default="'/tmp/install.out'">
                Stdout file
            </function-optional-arg>
            <function-optional-arg name="tms" default="'tms.lab.zimbra.com'">Location of TMS server</function-optional-arg>
        </function-map-args>
        <sequence>
            <if expr="jobId !='-1'">
                <sequence>
                    <log>'Notify termination of job %s' % jobId</log>
                    <process name="'End Job'">
                        <location>gMachines['tmsStax']</location>
                        <command>'/bin/env'</command>         
                        <workdir>'/opt/qa/tools'</workdir>     
                        <parms>'ruby /opt/qa/tools/endJob.rb %s %s' % (jobId, tms)</parms>         
                        <stdout mode="'append'">outputFile</stdout>
                        <stderr mode="'stdout'"/>
                    </process>
                </sequence>
            </if>
        </sequence>
    </function>

    <!--function name="buildID" scope="local">
        <function-prolog>
            This function extracts the build id from the build uri
        </function-prolog>
        <function-map-args>
            <function-optional-arg name="uri" default='bURL'>
                Build url
            </function-optional-arg>
        </function-map-args>
        <sequence>
            <script>
                #import re
                tokens=uri.split(delimiter[0])
                res=tokens[-2] + "_" + tokens[-1].split(".")[-2]
            </script>
            <return>res</return>
        </sequence>
    </function-->

    <function name="zimbraStatus" scope="local">
        <function-prolog>
            This function checks zimbra stat, returns zmcontrol exit code and output
        </function-prolog>
        <function-map-args>
            <function-required-arg name="machine">
                Which machine
            </function-required-arg>
            <function-required-arg name="file">
                Which file to append output to
            </function-required-arg>
            <function-optional-arg name="timeout" default="'90000'">
                Timeout in ms
            </function-optional-arg>
        </function-map-args>
        <sequence>
            <iterate var="i" in="range((int(timeout) + 10000)/10000)">
                <sequence>
                    <script>name="zmcontrol status on " + machine</script>
                    <process name="name">
                        <location>machine</location>
                        <command mode="'shell'">'su - zimbra -c "/opt/zimbra/bin/zmcontrol status"'</command>
                        <workdir>'/opt/zimbra/bin'</workdir>
                        <stdout mode="'append'">file</stdout>
                        <stderr mode="'stdout'"/>
                        <returnstdout/>
                    </process>
                    <script>res=[RC, STAXResult[0][1].splitlines()[-16:]]</script>
                    <if expr="(STAFResult != None) or (RC == STAFRC.Ok)">
                        <return>res</return>
                    </if>
                    <!--if expr="RC == STAFRC.Ok">
                        <return>[RC, STAXResult[0][1].splitlines()[-16:]]</return>
                    </if-->
                    <stafcmd name="'Delay'">
                        <location>'local'</location>
                        <service>'delay'</service>
                        <request>'delay 10000'</request>
                    </stafcmd>
               </sequence>
           </iterate>
           <return>[res[0], 'Services not running after %s seconds.'%(int(timeout) / 1000)]</return>
         </sequence>
    </function>

    <function name="createZmInst" scope="local">
        <function-prolog>
            This function is used to create config file
        </function-prolog>
        <function-map-args>
            <function-required-arg name="machine">
                Which machine
            </function-required-arg>
            <function-required-arg name="config">
                Config script used to create config file
            </function-required-arg>
            <function-optional-arg name="file">
                Config file name
            </function-optional-arg>
        </function-map-args>
        <sequence>
            <!--log>"createZmInst(%s, %s)" % (machine, config)</message-->
            <process name="'Create zmInst'">
                <location>machine</location>
                <command>'/bin/echo'</command>
                <workdir>'/tmp'</workdir>
                <parms>'%s' % config</parms>
                <stdout>file</stdout>  
            </process>
         </sequence>
    </function>

    <function name="uninstallLocal" scope="local">
        <function-prolog>
            This function is used to locally uninstall zimbra
        </function-prolog>
        <function-map-args>
            <function-required-arg name="machine">
                Name of the target machine
            </function-required-arg>
            <function-optional-arg name="currentZcs" default="'/var/tmp/zcs'">
                Crt zcs location
            </function-optional-arg>          
        </function-map-args>
        <sequence>
            <script>confirm = "Y\nY\n"</script>
            <process name="'Create Confirm'">
                <location>machine</location>
                <command>'/bin/echo'</command>
                <workdir>'/tmp'</workdir>
                <parms>'%s' % confirm</parms>
                <stdout>'/tmp/confirm.file'</stdout>  
            </process>
            <process name="'Uninstall - ' + machine">
                <location>machine</location>
                <command>'/bin/bash'</command> 
                <workdir>currentZcs</workdir>
                <parms>' -l -c "/bin/cat /tmp/confirm.file | ./install.sh -u"'</parms> 
                <stdout mode="'append'">outputFile[0]</stdout>  
                <stderr mode="'stdout'"/>
            </process>
            <!--stafcmd name="'Delete zimbra-cluster - ' + machine">
                <location>machine</location>
                <service>'FS'</service>
                <request>'delete entry /opt/zimbra-cluster recurse confirm'</request>
            </stafcmd-->
            <return>RC</return>
        </sequence>
    </function>

    <function name="untarLocal" scope="local">
        <function-prolog>
            This function is used to locally untar zimbra
        </function-prolog>
        <function-map-args>
            <function-required-arg name="machine">
                Name of the target machine
            </function-required-arg>
            <function-optional-arg name="workDirectory" default="'/var/tmp/'">
                Crt zcs location
            </function-optional-arg>          
            <function-optional-arg name="tarFile" default="'zcs.tgz'">
                Crt zcs location
            </function-optional-arg>          
        </function-map-args>
        <sequence>
            <script>
                gzipFilter = ''
                if tarFile.find('tgz') != -1:
                   gzipFilter = 'z'
            </script>
            <process name="'Get tar option - ' + machine">
                <location>machine</location>
                <command>'/bin/bash'</command>
                <workdir>workDirectory</workdir>
                <parms>'-l -c "tar --help | grep \\\"strip-\\\(path\\\|components\\\)\\\""'</parms>  
                <stdout>'/tmp/untar.out'</stdout>
                <stderr mode="'stdout'"/>
                <returnstdout/>
            </process>
            <script>
                if STAXResult[0][1].split('\n')[0].find('-components') != -1:
                   option = 'strip-components 1'
                else:
                   option = 'strip-path 1'
            </script>
            <process name="'Get tar file content - ' + machine">
                <location>machine</location>
                <command>'/bin/bash'</command>
                <workdir>workDirectory</workdir>
                <parms>'-l -c "tar -t%sf %s"' % (gzipFilter, tarFile)</parms>  
                <stdout>'/tmp/untar.out'</stdout>
                <stderr mode="'stdout'"/>
                <returnstdout/>
            </process>
            <if expr="RC != STAFRC.Ok">
                <return>[RC, 'untar %s failed, exit code %s, for more details see /tmp/untar.out.' %(tarFile, RC)]</return>
            </if>
            <script>
                lines = STAXResult[0][1].split('\n')
                if lines[0].replace('\n','').startswith('zcs-cluster'):
                   targetDirectory = 'zcs-cluster'
                else:
                   targetDirectory = 'zcs'
            </script>
            <stafcmd name="'Delete target dir'">
                <location>machine</location>
                <service>'FS'</service>
                <request>'delete entry %s%s recurse confirm' % (workDirectory, targetDirectory)</request>
            </stafcmd>
            <log>'delete entry %s%s recurse confirm' % (workDirectory, targetDirectory)</log>
            <stafcmd name="'Create target dir'">
                <location>machine</location>
                <service>'FS'</service>
                <request>'create directory %s%s' % (workDirectory, targetDirectory)</request>
            </stafcmd>
            <process name="'Untar'">
                <location>machine</location>
                <command>'tar'</command>
                <workdir>workDirectory+targetDirectory</workdir>
                <parms>'--%s -x%sf %s' % (option, gzipFilter, tarFile)</parms>  
                <stdout mode="'append'">'/tmp/untar.out'</stdout>
                <stderr mode="'stdout'"/>
                <!--returnstdout/-->
            </process>
<log>'tar --%s -x%sf %s' % (option, gzipFilter, tarFile)</log>
            <return>[RC, 'untar completed %s' % workDirectory + targetDirectory]</return>
        </sequence>
    </function>

    <function name="fixSudoers" scope="local">
        <function-prolog>
            This function is used to set proper access permission for
            base build to succeed
        </function-prolog>
        <function-map-args>
        <function-required-arg name="machine">
            Target machine
        </function-required-arg>
        <function-required-arg name="buildId">
            Build name
        </function-required-arg>
        <function-optional-arg name="outputFile" default="'/tmp/install.out'">
            Stdout file
        </function-optional-arg>
        </function-map-args>

        <sequence>
            <script>
                import re
                match=re.search('.*_SLES10_64_.*(\d{14,}).*', buildId)
                permissions=440
            </script>
            <if expr="(match != None) and (long(match.group(1)) >= long('20080416233334'))">
                <sequence>
                    <log>'Set sudoers access permissions %s - %s' % (permissions, machine)</log>
                    <process name="'chmod sudoers - ' + machine">
                        <location>machine</location>
                        <command>'/bin/chmod'</command>
	                <workdir>'/etc'</workdir>
                        <parms>'%s sudoers'%permissions</parms>
                        <stdout mode="'append'">outputFile</stdout>  
                        <stderr mode="'stdout'"/>
                     </process>
                </sequence>
            </if>
        </sequence>
    </function>

    <function name="cleanSudoers" scope="local">
        <function-prolog>
            This function is used to set proper access permission for
            base build to succeed
        </function-prolog>
        <function-map-args>
        <function-required-arg name="machine">
            Target machine
        </function-required-arg>
        <function-optional-arg name="outputFile" default="'/tmp/install.out'">
            Stdout file
        </function-optional-arg>
        </function-map-args>

        <sequence>
            <process name="'Clean sudoers - ' + machine">
                <location>machine</location>
                <command>'sed'</command>
	    	    <workdir>'/etc'</workdir>
                <parms>"--in-place=.bak '/^%zimbra.*$/D' /etc/sudoers"</parms>
                <stdout mode="'append'">outputFile</stdout>
                <stderr mode="'stdout'"/>
            </process>
	    	<return>[RC, '%s - back up sudoers %s.'%(machine, '/etc/sudoers.bak')]</return>
        </sequence>
    </function>

    <function name="runShellScripts" scope="local">
    
        <function-prolog>
            Main entry point to set up global variables
        </function-prolog>
        
        <function-map-args>
                
            <function-required-arg name="directory">
                script directory
            </function-required-arg>

            <function-optional-arg name="machine" default="'qa03'">
                Name of the target machine
            </function-optional-arg>

            <function-optional-arg name="parameters" default="[]">
               parameters to pass on scripts
            </function-optional-arg>

            <function-optional-arg name="log" default="'/tmp/install.out'">
                Stdout file
            </function-optional-arg>

            <function-optional-arg name="ignoreError" default="'1'">
               Ignore errors
            </function-optional-arg>

        </function-map-args>
        
        <sequence>
            <script>STAXMessageLog=1</script>
            <stafcmd name="'Get scripts to run - ' + machine">
                <location>machine</location>
                <service>'FS'</service>
                <request>'list directory %s type f' % directory</request>
            </stafcmd>

            <if expr="RC != 0">
                <sequence>
                    <log>'could not find script list to run RC=%s, STAFResult=%s'%(RC,STAFResult)</log>
                    <return>failed</return>
                </sequence>
            </if>
            <log>'list=%s'%STAFResult</log>
            <script>testList=STAFResult</script>
            <!--script>pars="-bits " + bits + " -machine " + machine + " -needReboot " + needReboot + " -OS " + OS</script-->
            <script>pars=['-bits', bits, '-machine', machine, '-OS', OS, '-build', build, '-branch', branch,\
                          '-baseBuild', baseBuild, 'targetBuild', targetBuild]</script>
            <process name="'chmod +x'">
                 <location>machine</location>
                 <command>'/bin/bash'</command>
	         <workdir>directory</workdir>
                 <parms>'-l -c "chmod a+x *"'</parms>
                 <stdout mode="'append'">log</stdout>  
                 <stderr mode="'stdout'"/>
                 <!--returnstdout/-->
            </process>
            <script>
                 testPass = len(testList)
                 testFail = 0
                 passFail=passed
            </script>
            <iterate var="test" in="testList">
                <sequence>
                    <process name="'Run ' + test + ' on ' + machine">
                        <location>machine</location>
                        <command>'/bin/env'</command>         
                        <workdir>directory</workdir>
                        <parms>'./%s %s'%(test, " ".join(parameters))</parms>
                        <stdout mode="'append'">log</stdout>
                        <stderr mode="'stdout'"/>
                        <returnstdout/>
                    </process>
                    <if expr="RC != 0">
                        <sequence>
                            <script>
                                testPass -= 1
                                testFail += 1
                            </script>
                            <log>'script %s failed, RC=%s, STAFResult=%s, STAXResult=%s'%(test,RC,STAFResult,STAXResult)</log>
                            <if expr="ignoreError == '0'">
                                <return>failed</return>
                                <else>
                                    <script>passFail=failed</script>
                                </else>
                            </if>
                        </sequence>
                    </if>
                    <log>'Test %s completed, RC=%s'%(test, RC)</log>
                </sequence>
            </iterate>
            <return>passFail + ": Passed " + str(testPass) + ", Failed " + str(testFail)</return>
        </sequence>
    </function>

    <function name="getBuild">
        <function-prolog>
            This function is used to fetch build from Zimbra build server
        </function-prolog>
        <function-map-args>
            <function-required-arg name="buildURL">
                Which build to install
            </function-required-arg>
        </function-map-args>
        <sequence>
        <process name="'Get Build'">
            <location>'qa11'</location>
            <command mode="'shell'">'/bin/bash'</command> 
            <workdir>'/opt/cluster/bin'</workdir>
            <parms>' -c "./get-build.pl %s"' % buildURL</parms> 
            <stdout>'/tmp/install.out'</stdout>
            <stderr mode="'stdout'"/>
            <returnstdout/>
        </process>
        <log>'get build %s, RC=%s, STAXResult=%s' % (buildURL, RC, STAXResult)</log>
        </sequence>
    </function>

    <function name="cluster">
        <function-prolog>
            This function is used to manage the cluster
        </function-prolog>
        <function-map-args>
            <function-required-arg name="action">
                Available actions are start|stop|status
            </function-required-arg>
            <function-optional-arg name="machine" default="'qa12'">
                Name of the target machine
            </function-optional-arg>
        </function-map-args>
        <sequence>
            <timer duration="stopTimeout">
                <sequence>
                    <process name="'rhcs'">
                        <location>machine</location>
                        <command mode="'shell'">'/bin/bash'</command> 
                        <workdir>'/opt/cluster/bin'</workdir>
                        <parms>' -c "./rhcs %s"' % action </parms> 
                        <stdout>'/tmp/install.out'</stdout>
                        <stderr mode="'stdout'"/>
                        <returnstdout/>
                    </process>
                    <log>'cluster %s on %s, RC=%s, STAXResult=%s' % (action, machine, RC, STAXResult)</log>
                    <return>passed</return>
                </sequence>
            </timer>
            <log>'cluster %s on %s, RC=%s, STAXResult=%s' % (action, machine, RC, STAXResult)</log>
            <return>failed</return>
        </sequence>
    </function>

    <function name="installSoftware" scope="local">
        <function-prolog>
            This function runs install on the target machine
                On MACOSX it should always be used in softwareOnly mode
        </function-prolog>
        <function-map-args>
            <function-required-arg name="machine">
                Name of the target machine
            </function-required-arg>
            <function-required-arg name="installTemplate">
                configuration
            </function-required-arg>
            <function-required-arg name="OS">
                configuration
            </function-required-arg>
            <function-optional-arg name="build" default="'foo'">
                Name of the build
            </function-optional-arg>        

            <function-optional-arg name="branch" default="'mebranch'">
                Name of the branch
            </function-optional-arg>

            <function-optional-arg name="timestamp" default="'whenever'">
                Time Stamp
            </function-optional-arg>

            <function-optional-arg name="buildUri" default="'/var/tmp/basebuild/zcs_foo_blah.tgz'">
               Need setting up test ware
            </function-optional-arg>

            <function-optional-arg name="softwareOnly" default="'-s'">
                Time Stamp
            </function-optional-arg>
                       
            <function-optional-arg name="makeBackup" default="'1'">
                Time Stamp
            </function-optional-arg>
            
        </function-map-args>
        <sequence>
            <process name="'Log Message'">
                <location>machine</location>
                <command>'/bin/echo'</command>
                <workdir>'/tmp'</workdir>
                <parms>'Install zimbra:'</parms>
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
            </process>
            <script>
                platform = OS
            </script>
            <if expr="platform is None">
                <sequence>
                    <log>'no install, platf=%s'%STAXResult</log>
                    <return>None</return>
                </sequence>
            </if>
            <script>res = passed</script>
            <if expr="platform.startswith('MACOSX')">
                <sequence>
                    <process name="'Detach zimbra - ' + machine">
                        <location>machine</location>
                        <command>'/usr/libexec/StartupItemContext'</command>
                        <workdir>'/var/tmp'</workdir>
                        <parms>'/bin/df /var/tmp/zimbra'</parms>
                    </process>
                    <if expr="RC == STAFRC.Ok">
                        <process name="'UnMount zimbra - ' + machine">
                            <location>machine</location>
                            <command>'/usr/libexec/StartupItemContext'</command>
                            <workdir>'/var/tmp'</workdir>
                            <parms>'/usr/bin/hdiutil detach /var/tmp/zimbra'</parms>  
                            <stdout mode="'append'">outputFile[0]</stdout>
                            <stderr mode="'stdout'"/>
                        </process>
                    </if>
                    <log>'%s software install - %s'%(platform, machine)</log>
                    <script>
                        ofile = '/var/tmp/zcs.dmg'
                        templateFile = '/var/tmp/zimbra/zcs.mpkg/Contents/distribution.dist'</script>
                    <!-- delete zcs.dmg -->
                    <stafcmd name="'Delete ' + ofile + ' - ' + machine">
                        <location>machine</location>
                        <service>'FS'</service>
                        <request>'delete entry %s confirm' % ofile</request>
                    </stafcmd>
                    <!-- hdiutil convert buildUri -format UDRW -o zcs.dmg 
                         and mount it below -->
                    <process name="'Convert dmg to RW image - ' + machine">
                        <location>machine</location>
                        <command>'/usr/libexec/StartupItemContext'</command>
                        <workdir>'/var/tmp'</workdir>
                        <parms>'/usr/bin/hdiutil convert %s -format UDRW -o %s' % (buildUri, ofile)</parms>  
                        <stdout mode="'append'">outputFile[0]</stdout>
                        <stderr mode="'stdout'"/>
                    </process>
                    <process name="'Mount - ' + machine">
                        <location>machine</location>
                        <command>'/usr/libexec/StartupItemContext'</command>
                        <workdir>'/var/tmp'</workdir>
                        <parms>'/usr/bin/hdiutil attach -mountpoint /var/tmp/zimbra %s' % ofile</parms>  
                        <stdout mode="'append'">outputFile[0]</stdout>
                        <stderr mode="'stdout'"/>
                    </process>
                    <!-- replace  /var/tmp/zimbra/zcs.mpkg/Contents/distribution.dist with installTemplate -->
                    <stafcmd>
                        <location>machine</location>
                        <service>'fs'</service>
                        <request>'COPY FILE %s TOFILE %s.orig TOMACHINE %s FAILIFEXISTS'%(templateFile, templateFile, machine)</request>
                    </stafcmd>
                    <call function="'genInstallTemplatesMAC'">
                        {'file' : configuration,
                         'machine' : machine
                        }
                    </call>
                    <if expr="STAXResult[0] != STAFRC.Ok">
                        <sequence>
                            <log message="1" level="'debug'">'gen install templates error - %s'%STAXResult[1]</log>
                        </sequence>
                        <else>
                            <sequence>
                                <stafcmd>
                                    <location>'local'</location>
                                    <service>'fs'</service>
                                    <request>'COPY FILE %s TOFILE %s TOMACHINE %s'%(STAXResult[1], templateFile, machine)</request>
                                </stafcmd>
                            </sequence>
                        </else>
                    </if>
                    <process name="'Install Package Step One - ' + machine">
                        <location>machine</location>
                        <command>'/usr/sbin/installer'</command>
                        <workdir>'/var/tmp'</workdir>
                        <parms>'-config -pkg /var/tmp/zimbra/zcs.mpkg -target "/"'</parms>  
                        <stdout>'/tmp/install.xml'</stdout>
                    </process>
                    <process name="'Install Package Step Two'">
                        <location>machine</location>
                        <command>'/bin/bash'</command>
                        <workdir>'/var/tmp'</workdir>
                        <parms>'-l -c "time -p /usr/sbin/installer -dumplog -file /tmp/install.xml"'</parms>  
                        <stdout mode="'append'">outputFile[0]</stdout>
                        <stderr mode="'stdout'"/>
                    </process>
                    <script>
                        if RC == STAFRC.Ok:
                           res = passed
                        else:
                           res = failed
                    </script>
                    <!-- if proxy/archiving in config-->
<!-- installer -target / -pkg /var/tmp/zimbra/zcs.mpkg/Contents/.Packages/zimbra-archiving.pkg
     installer -target / -pkg /var/tmp/zimbra/zcs.mpkg/Contents/.Packages/zimbra-proxy.pkg -->
                    <!--call function="'parseXML'">toConfig</call>
                    <script>document = STAXResult</script-->
                    <!--call function="'getNodePackages'">
                        {'machine':machine,
                         'document':document
                        }
                    </call>
                    <script>
                        nodePkgs = STAXResult
                    </script>
                    <iterate var="package" in="['zimbra-proxy', 'zimbra-archiving']">
                        <if expr="package in nodePkgs">
                            <sequence>
                                <process name="'Install Package Step Two'">
                                    <location>machine</location>
                                    <command>'/bin/bash'</command>
                                    <workdir>'/var/tmp'</workdir>
                                    <parms>'-l -c "time -p /usr/sbin/installer -dumplog -target / -pkg /var/tmp/zimbra/zcs.mpkg/Contents/.Packages/%s.pkg"'%package</parms>  
                                    <stdout mode="'append'">outputFile[0]</stdout>
                                    <stderr mode="'stdout'"/>
                                </process>
                                <script>
                                    if RC != STAFRC.Ok:
                                       res = failed
                                </script>
                            </sequence>
                        </if>
                    </iterate-->
                    <!--call function="'updateHistory'">
                       {'machine'  : machine,
                        'buildName': buildUri}
                    </call-->
                    <process name="'UnMount zimbra - ' + machine">
                        <location>machine</location>
                        <command>'/usr/libexec/StartupItemContext'</command>
                        <workdir>'/var/tmp'</workdir>
                        <parms>'/usr/bin/hdiutil detach /var/tmp/zimbra'</parms>  
                        <stdout mode="'append'">outputFile[0]</stdout>
                        <stderr mode="'stdout'"/>
                    </process> 
                    <return>res</return>
                </sequence>
            </if>
            <log>'%s install - %s'%(platform, machine)</log>
            <!--call function="'untarLocal'">
                {'machine':machine,'tarFile':buildUri}
            </call>
            <if expr="STAXResult[0] != 0">
                <script>res = failed</script>
            </if>
            <log>"%s untar result %s" % (machine, res)</log>
            <if expr="res == failed">
                <return>res</kill-return>
            </if-->
            <call function="'fixSudoers'">
                {'machine': machine,
                 'buildId'     : os.path.basename(buildUri),
                 'outputFile' : outputFile[0]}
            </call>
            <process name="'Create Install File - ' + machine">
                <location>machine</location>
                <command>'/bin/echo'</command>
                <workdir>'/tmp'</workdir>
                <parms>'%s' % installTemplate</parms>
                <stdout>'/tmp/zmInst.rb'</stdout>  
            </process>
            <script>
                installError = STAXGlobal([0])
                sizeExceeded = STAXGlobal([0])
                installBlock = 'installBlock.' + machine
            </script>
            <block name="installBlock">
                <parallel>
                    <sequence>
                        <log>'i %s, %s.'%(softwareOnly, installTemplate)</log>
                        <!--process name="'Install - ' + machine">
                            <location>machine</location>
                            <command>'/bin/bash'</command> 
                            <workdir>'/var/tmp/zcs'</workdir>
                            <parms>' -l -c "time -p /bin/echo -e \\\"%s\\\" | ./install.sh %s"' % (installTemplate, softwareOnly)</parms> 
                            <stdout  mode="'append'">outputFile[0]</stdout>
                            <stderr mode="'stdout'"/>
                        </process-->
                        <!--process name="'Install - ' + machine">
                            <location>machine</location>
                            <command>'/bin/bash'</command> 
                            <workdir>'/var/tmp/zcs'</workdir>
                            <parms>' -l -c "time -p ./install.sh %s &lt; %s"' % (softwareOnly, '/tmp/zmInst.txt')</parms> 
                            <stdout  mode="'append'">outputFile[0]</stdout>
                            <stderr mode="'stdout'"/>
                        </process-->
                        <process name="'Install - ' + machine">
                            <location>machine</location>
                            <command>'/bin/bash'</command> 
                            <workdir>'/var/tmp/zcs'</workdir>
                            <parms>' -l -c "source ./util/utilfunc.sh; source ./util/globals.sh; rm -rf $LOGFILE; time -p ruby /tmp/zmInst.rb &gt;&gt; %s"'%outputFile[0]</parms> 
                            <stdout>'/tmp/rt.txt'</stdout>
                            <stderr mode="'stdout'"/>
                            <returnstdout/>
                        </process>
                        <log>'Install %s RC=%s, STAXResult=%s' % (machine, RC, STAXResult)</log>
                        <if expr="RC != STAFRC.Ok">
                            <script>
                               installError[0] = 1
                            </script>
                        </if>
                        <script>msg = "\nRunning Time:\n" + STAXResult[0][1] + "\n"</script>
                        <process name="'Log running time'">
                            <location>machine</location>
                            <command>'/bin/echo'</command>
                            <workdir>'/tmp'</workdir>
                            <parms>'%s' % msg</parms>
                            <stdout mode="'append'">outputFile[0]</stdout>
                            <stderr mode="'stdout'"/>
                        </process>
                        <terminate block="'main.' + installBlock"/>
                    </sequence>
                    <sequence>
                        <timer duration="'120m'">
                            <loop>
                                <sequence>
                                    <process name="'detect error'">
                                        <location>machine</location>
                                        <command>'/bin/bash'</command> 
                                        <workdir>'/var/tmp/'</workdir>
                                        <parms>' -l -c "sleep 5s;\
                                                        set `du -k %s`;\
                                                        if [ $1 -gt %s ]; then\
                                                             exit 1;\
                                                           else\
                                                             exit 0;\
                                                        fi"' % (outputFile[0],int(maxSize[0])/1000)</parms> 
                                        <stdout>'/tmp/timer'</stdout>
                                        <stderr mode="'stdout'"/>
                                        <!--returnstdout/-->
                                    </process>
                                    <script>sizeExceeded[0] = RC</script>
                                    <if expr="sizeExceeded[0] != 0">
                                        <sequence>
                                            <log>'terminate block, maxSize exceeded=%s'%sizeExceeded[0]</log>
                                            <terminate block="'main.' + installBlock"/>
                                        </sequence>
                                    </if>
                                </sequence>
                            </loop>
                        </timer>
                        <log>'terminate block anyway'</log>
                        <script>installError[0] = 1</script>
                        <terminate block="'main.' + installBlock"/>
                    </sequence>
                </parallel>
            </block>
            <if expr="sizeExceeded[0] != 0">
                <sequence>
                    <process name="'Truncate log - ' + machine">
                        <location>machine</location>
                        <command>'/bin/env'</command> 
                        <workdir>'/opt/zimbra'</workdir>
                        <parms>'ruby -e "File.truncate(\'%s\', 40000)"'%outputFile[0]</parms> 
                        <stdout mode="'append'">outputFile[0]</stdout>
                        <stderr mode="'stdout'"/>
                        <!--returnstdout/-->
                    </process>
                    <log>'ze=%s,res=%s'%(sizeExceeded[0], RC)</log>
                </sequence>
            </if>
            <script>
                if installError[0] or sizeExceeded[0]:
                    res = failed
                else:
                    res = passed
            </script>
            <if expr="makeBackup == '1'">
                <sequence>
                    <!--call function="'updateHistory'">
                        {'machine'  : machine,
                         'buildName': buildUri}
                    </call-->
                    <!-- delete .uninstall first -->
                    <stafcmd name="'Delete uninstall - ' + machine">
                        <location>machine</location>
                        <service>'FS'</service>
                        <request>'delete entry /opt/zimbra/.uninstall recurse confirm'</request>
                    </stafcmd>
                    <process name ="'Move image - ' + machine">
                           <location>machine</location>
                           <command>'/bin/mv'</command>
                           <workdir>'/var/tmp'</workdir>
                           <parms>'/var/tmp/zcs /opt/zimbra/.uninstall'</parms>                        
                    </process>
                </sequence>
            </if>
            <log>'Completed installation on %s, res=%s' % (machine, res)</log>
            <return>res</return>
        </sequence>
    </function>


    <function name="uninstallSoftware" scope="local">
        <function-prolog>
            This function runs uninstall zimbra on the target machine
        </function-prolog>
        <function-map-args>
            <function-required-arg name="machine">
                Name of the target machine
            </function-required-arg>

            <function-required-arg name="OS">
               Need setting up test ware
            </function-required-arg>

            <function-optional-arg name="build" default="'foo'">
                Name of the build
            </function-optional-arg>        

            <function-optional-arg name="branch" default="'mebranch'">
                Name of the branch
            </function-optional-arg>

          <function-optional-arg name="timestamp" default="'whenever'">
                Time Stamp
            </function-optional-arg>

            <function-optional-arg name="needReboot" default="'1'">
                Time Stamp
            </function-optional-arg>

        </function-map-args>

        <sequence>
            <log message="1" level="'debug'">'uninstallSoftware(OS=%s, build=%s, branch=%s, timestamp=%s, needReboot=%s, outputFile=%s)'% \
                                               (OS, build, branch, timestamp, needReboot, outputFile[0])</log>
            <process name="'Log Message'">
                <location>machine</location>
                <command>'/bin/echo'</command>
                <workdir>'/tmp'</workdir>
                <parms>'Uninstall zimbra:'</parms>
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
            </process>
            <script>
                #platform = buildUri.split(delimiter[0])[1]
                platform = OS
            </script>
            <if expr="platform is None">
                <sequence>
                    <log>'no uninstall, platf=%s'%STAXResult</log>
                    <return>None</return>
                </sequence>
            </if>
            <if expr="platform.startswith('MACOSX')">
                <sequence>
                    <script>uninstallDir = '/opt/zimbra/libexec/installer'</script>
                    <stafcmd>
                        <location>machine</location>
                        <service>'fs'</service>
                        <request>'query entry %s'%uninstallDir</request>
                    </stafcmd>
                    <if expr="RC == 0">
                        <sequence>
                            <script>confirm = "Y\nY\n"</script>
                            <process name="'Create Confirm'">
                                <location>machine</location>
                                <command>'/bin/echo'</command>
                                <workdir>'/tmp'</workdir>
                                <parms>'%s' % confirm</parms>
                                <stdout>'/tmp/confirm.file'</stdout>  
                            </process>
                            <process name="'Uninstall - ' + machine">
                                <location>machine</location>
                                <command>'/bin/bash'</command> 
                                <workdir>uninstallDir</workdir>
                                <parms>' -l -c "/bin/cat /tmp/confirm.file | ./install-mac.sh -u"'</parms> 
                                <stdout mode="'append'">outputFile[0]</stdout>  
                                <stderr mode="'stdout'"/>
                            </process>
                            <return>[RC, 'Uninstall complete']</return>
                        </sequence>
                    </if>
                    <!-- mac old way uninstall -->
                    <log>'Shutdown zimbra server'</log>
                    <process name="'Disable Launch D - ' + machine">
                        <location>machine</location>
                        <command>'/bin/launchctl'</command>
                        <workdir>'/tmp'</workdir>
                        <parms>'unload -w /System/Library/LaunchDaemons/com.zimbra.zcs.plist'</parms>
                        <stdout mode="'append'">outputFile[0]</stdout>
                        <stderr mode="'stdout'"/>
                    </process>  
                    <log>'Stop Zimbra'</log>  
                    <process name="'Stop Zimbra'">
                        <location>machine</location>
                        <command>'/bin/launchctl'</command>
                        <workdir>'/tmp'</workdir>
                        <parms>'stop com.zimbra.zcs'</parms>
                        <stdout mode="'append'">outputFile[0]</stdout>
                        <stderr mode="'stdout'"/>
                    </process>  
                    <process name="'Shutdown ' + machine">
                        <location>machine</location>
                        <command>'/bin/su'</command>
                        <workdir>'/var/tmp'</workdir>
                        <parms>'zimbra -c "/opt/zimbra/bin/zmcontrol stop"'</parms>  
                        <stdout mode="'append'">outputFile[0]</stdout>
                        <stderr mode="'stdout'"/>
                    </process> 
                    <log>'Clean zimbra files processes'</log>     
                    <script>
                        removeTemplate = "rm -v -R -f /Library/Receipts/zimbra*\nps -U zimbra -o pid='' | xargs kill -9\n"
                        removeTemplate += "ps -A | grep -i zimbra | perl -nle '@result = split; print $result[0];' | xargs kill -9\n"
                        removeTemplate += "ps -A | grep -i amavisd | perl -nle '@result = split; print $result[0];' | xargs kill -9\n"
                        removeTemplate += "ps -U zimbra | grep -v mdimportserver | perl -nle '@result = split; print $result[0];' | xargs kill -9\n"
                    </script>
                    <process name="'Create Remove File - ' + machine">
                        <location>machine</location>
                        <command>'/bin/echo'</command>
                        <workdir>'/tmp'</workdir>
                        <parms>'%s' % removeTemplate</parms>
                        <stdout>'/tmp/remove.file'</stdout>  
                    </process>

                    <process name="'Chmod +x - ' + machine">
                        <location>machine</location>
                        <command>'/bin/env'</command>
                        <workdir>'/tmp'</workdir>
                        <parms>'chmod u+x /tmp/remove.file'</parms>
                      <stdout mode="'append'">outputFile[0]</stdout>
                        <stderr mode="'stdout'"/>
                    </process>              
	    	    
                    <process name="'Clean Zimbra Receipts and Kill process - ' + machine">
                        <location>machine</location>
                        <command>'/bin/bash'</command>
                        <workdir>'/tmp'</workdir>
                        <parms>'-c /tmp/remove.file'</parms>  
                        <stdout mode="'append'">outputFile[0]</stdout>
                        <stderr mode="'stdout'"/>
                    </process>
	    	    
                    <call function="'cleanSudoers'">
                        {'machine': machine}
                    </call>
                    
                    <stafcmd>
                        <location>machine</location>
                        <service>'fs'</service>
                        <request>'query entry /opt/zimbra'</request>
                    </stafcmd>
                    <if expr="RC == STAFRC.Ok">
                        <process name="'Delete /opt/zimbra - ' + machine">
                            <location>machine</location>
                            <command>'/bin/bash'</command>
                            <workdir>'/opt/zimbra'</workdir>
                            <parms>'-l -c "rm -rf .[^.] .??*"'</parms>
                            <stdout mode="'append'">outputFile[0]</stdout>  
                            <stderr mode="'stdout'"/>
                        </process>
                    </if>
                    
                    <process name="'Delete /var/spamassassin - ' + machine">
                        <location>machine</location>
                        <command>'/bin/rm'</command>
                        <workdir>'/tmp'</workdir>
                        <parms>'-r -f /var/spamassassin'</parms>  
                        <stdout mode="'append'">outputFile[0]</stdout>
                        <stderr mode="'stdout'"/>
                    </process>

                    <process name="'UnMount zimbra - ' + machine">
                        <location>machine</location>
                        <command>'/usr/libexec/StartupItemContext'</command>
                        <workdir>'/var/tmp'</workdir>
                        <parms>'/usr/bin/hdiutil detach /var/tmp/zimbra'</parms>  
                        <stdout mode="'append'">outputFile[0]</stdout>
                        <stderr mode="'stdout'"/>
                    </process>
                    <log>'Uninstall complete on ' + machine</log>    
                    <return>[STAFRC.Ok, 'Uninstall complete']</return>
                </sequence>
            </if>
            
            <script>uninstallDir = '/var/tmp/zcs'</script>
            <stafcmd>
                <location>machine</location>
                <service>'fs'</service>
                <request>'query entry %s'%uninstallDir</request>
            </stafcmd>
            <if expr="RC != 0">
                <sequence>
                    <script>uninstallDir = '/opt/zimbra/.uninstall'</script>
                    <stafcmd>
                        <location>machine</location>
                        <service>'fs'</service>
                        <request>'query entry %s'%uninstallDir</request>
                    </stafcmd>
                    <if expr="RC != 0">
                        <script>uninstallDir = '/opt/zimbra/libexec/installer'</script>
                    </if>
                </sequence>                                                          
            </if>
            <call function="'uninstallLocal'">
                {'machine' : machine, 'currentZcs' : uninstallDir}
            </call>
            <stafcmd>
                <location>machine</location>
                <service>'fs'</service>
                <request>'query entry %s'%'/sbin/chkconfig'</request>
            </stafcmd>
            <if expr="RC == 0">
                <sequence>
                    <process name="'Disable AutoStart - ' + machine">
                        <location>machine</location>
                        <command>'/sbin/chkconfig'</command>
                        <workdir>'/tmp'</workdir>
                        <parms>'--list zimbra'</parms>
                        <stdout>'/tmp/uninstall.out'</stdout>
                        <stderr mode="'stdout'"/>
                        <returnstdout/>
                    </process>
                    <if expr="RC == STAFRC.Ok and STAXResult[0][1].find('zimbra: unknown service') == -1">
                        <sequence>
                            <process name="'Log Message'">
                                <location>machine</location>
                                <command>'/bin/echo'</command>
                                <workdir>'/tmp'</workdir>
                                <parms>'ERROR: uninstall expected to delete zimbra startup script(s)'</parms>
                                <stdout mode="'append'">outputFile[0]</stdout>
                                <stderr mode="'stdout'"/>
                            </process>
                            <process name="'Disable AutoStart - ' + machine">
                                <location>machine</location>
                                <command>'/sbin/chkconfig'</command>
                                <parms>'--del zimbra'</parms>
                                <stdout mode="'append'">outputFile[0]</stdout>
                                <stderr mode="'stdout'"/>
                            </process>
                        </sequence>
                    </if>
                </sequence>                                                          
            </if>
            <stafcmd>
                <location>machine</location>
                <service>'fs'</service>
                <request>'query entry %s'%'/usr/sbin/update-rc.d'</request>
            </stafcmd>
            <if expr="RC == 0">
                <sequence>
                    <process name="'Check zimbra AutoStart - ' + machine">
                        <location>machine</location>
                        <command>'/usr/bin/perl'</command>
                        <workdir>'/tmp'</workdir>
                        <parms>' /usr/sbin/update-rc.d zimbra remove'</parms>
                    </process>
                    <if expr="RC != STAFRC.Ok">
                        <sequence>
                            <process name="'Log Message'">
                                <location>machine</location>
                                <command>'/bin/echo'</command>
                                <workdir>'/tmp'</workdir>
                                <parms>'ERROR: uninstall expected to delete zimbra startup script(s)'</parms>
                                <stdout mode="'append'">outputFile[0]</stdout>
                                <stderr mode="'stdout'"/>
                            </process>
                            <process name="'Disable AutoStart DEBIAN Style - ' + machine">
                                <location>machine</location>
                                <command>'/usr/bin/perl'</command>
                                <workdir>'/tmp'</workdir>
                                <parms>' /usr/sbin/update-rc.d -f zimbra remove'</parms>
                                <stdout mode="'append'">outputFile[0]</stdout>
                                <stderr mode="'stdout'"/>
                            </process>
                        </sequence>
                    </if>
                </sequence>                                                          
            </if>
            <process name="'Clean Directory - ' + machine ">
                <location>machine</location>
                <command>'/bin/rm'</command>
                <workdir>'/var/tmp'</workdir>
                <parms>'-r -f zcs'</parms>  
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
	        </process> 
            <process name="'Clean zimbra log - ' + machine">
                <location>machine</location>
                <command>'/bin/rm'</command>
	            <workdir>'/var/log'</workdir>
                <parms>'-f zimbra.log'</parms>
                <stdout mode="'append'">outputFile[0]</stdout>  
                <stderr mode="'stdout'"/>
            </process>
            <call function="'cleanSudoers'">
                {'machine': machine}
            </call>
            <if expr="OS.find('RHEL4') != -1">
                <call function="'disableCluster'">
                    {'machine': machine,
                     'cluster'     : 'RCS',
                     'outputFile' : outputFile[0]}
                </call>
            </if>
            <process name="'Remove Crontab - ' + machine">
                <location>machine</location>
                <command>'/usr/bin/crontab'</command>
                <parms>'-r -u zimbra'</parms>  
                <!--stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/-->
	        </process>
            <process name="'Remove users and groups - ' + machine">
                <location>machine</location>
                <command>'/bin/bash'</command>
                <parms>'-l -c "userdel zimbra; userdel postfix; groupdel zimbra; groupdel postfix; groupdel postdrop"'</parms>
                <!--stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/-->
	        </process>
	        <stafcmd>
                <location>machine</location>
                <service>'fs'</service>
                <request>'query entry /opt/zimbra'</request>
            </stafcmd>
            <if expr="RC == STAFRC.Ok">
                <process name="'Delete /opt/zimbra - ' + machine">
                    <location>machine</location>
                    <command>'/bin/bash'</command>
	                <workdir>'/opt/zimbra'</workdir>
                    <parms>'-l -c "rm -rf .[^.] .??*"'</parms>
                    <stdout mode="'append'">outputFile[0]</stdout>  
                    <stderr mode="'stdout'"/>
                </process>
            </if>
            <process name="'Delete /var/spamassassin - ' + machine">
                <location>machine</location>
                <command>'/bin/rm'</command>
                <workdir>'/tmp'</workdir>
                <parms>'-rf /var/spamassassin'</parms>
                <stdout mode="'append'">outputFile[0]</stdout>  
                <stderr mode="'stdout'"/>
            </process>
            <script>cmd = '/usr/sbin/tmpwatch'</script>
            <process name="'Cleanup /tmp - ' + machine">
                <location>machine</location>
                <command>'/bin/bash'</command>
                <parms>'-l -c "if [ -x %s ]; then %s -m 240 /tmp; fi"'%(cmd, cmd)</parms>
                <stdout mode="'append'">outputFile[0]</stdout>  
                <stderr mode="'stdout'"/>
            </process>
            <if expr="needReboot == '1'">
                <sequence>
                    <script>STAFServicesDir='/opt/qa/main/staf/'</script>
                    <stafcmd>
                        <location>gMachines['tms']</location>
                        <service>'var'</service>
                        <request>'resolve string %s' % STAFServicesDir</request>
                    </stafcmd>
                    <if expr="RC == 0">
                        <sequence>
                            <script>STAFServicesDir = STAFResult</script>
                        </sequence>
                        <else>
                            <sequence>
                                <log>
                                    'Error resolving STAFServicesDir: RC=%s, STAFResult=%s, \
                                     STAFServicesDir=%s' % (RC, STAFResult, STAFServicesDir)
                                </log>
                                <log>'Terminating job'</log>
                                <terminate block="'main'"/>
                            </sequence>
                        </else>
                    </if>
                    <script>rebootxml='%s%s'%(STAFServicesDir,"reboot.xml")</script>
                    <import machine="gMachines['tmsStax']" file="rebootxml"/>
                    <call function="'reboot'">
                        {'machine' : machine }
                    </call>
                </sequence>
            </if>

            <log>'Uninstall complete on %s' % machine</log>
            <return>[STAFRC.Ok, 'Uninstall complete']</return>
        </sequence>
    </function>

    <function name="runZmsetup" scope="local">
        <function-prolog>
            This function runs zmsetup -c ...
        </function-prolog>
        <function-map-args>
            <function-required-arg name="machine">
                Name of the target machine
            </function-required-arg>

            <function-required-arg name="config">
                The configuration
            </function-required-arg>

            <function-optional-arg name="build" default="'foo'">
                Name of the build
            </function-optional-arg>        

            <function-optional-arg name="branch" default="'mebranch'">
                Name of the branch
            </function-optional-arg>

            <function-optional-arg name="timestamp" default="'whenever'">
                Time Stamp
            </function-optional-arg>

            <function-optional-arg name="buildUri" default="'/var/tmp/basebuild/zcs_foo_blah.tgz'">
               Need setting up test ware
            </function-optional-arg>
                       
            <function-optional-arg name="timeout" default="'20m'">
               Need setting up test ware
            </function-optional-arg>
                       
        </function-map-args>

        <sequence>
            <!--call function="'buildID'">{'uri':buildUri}</call>
            <script>id=STAXResult</script>
            <script>outputFile[0]="/tmp/install.out." + id</script-->
            <script>useExpect = config.find('ruby') != -1</script>
            <process name="'Log Message'">
                <location>machine</location>
                <command>'/bin/echo'</command>
                <workdir>'/tmp'</workdir>
                <parms>'Configure zimbra:'</parms>
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
            </process>

            <process name="'Create config' + machine">
                <location>machine</location>
                <command>'/bin/echo'</command>
                <workdir>'/tmp'</workdir>
                <parms>'%s' % config</parms>
                <stdout>'/tmp/config.txt'</stdout>  
            </process>

            <script>
                zmsetupError = STAXGlobal([0])
                sizeExceeded = STAXGlobal([0])
                lastSize = STAXGlobal([0])
                installBlock = 'installBlock.' + machine
            </script>
            <block name="installBlock">
                <parallel>
                    <sequence>
                        <script>
                            param_list = '/bin/cat /tmp/config.txt | /bin/env perl /opt/zimbra/libexec/zmsetup.pl'
                            if useExpect:
                              param_list = 'ruby /tmp/zmupgrade.rb'
                        </script>
                        <process name="'zmsetup - ' + machine">
                            <location>machine</location>
                            <command>'/bin/bash'</command> 
                            <workdir>'/opt/zimbra'</workdir>
                            <!--parms>' -l -c "time -p /bin/cat /tmp/config.txt | /bin/env perl /opt/zimbra/libexec/zmsetup.pl"'</parms--> 
                            <parms>' -l -c "time -p %s"'%param_list</parms>
                            <stdout mode="'append'">outputFile[0]</stdout>
                            <stderr mode="'stdout'"/> 
                        </process>
                        <log>'Install %s RC=%s, STAXResult=%s' % (machine, RC, STAXResult)</log>
                        <script>
                            if RC != STAFRC.Ok:
                               zmsetupError[0]=1
                        </script>
                        <terminate block="'main.' + installBlock"/>
                    </sequence>
                    <sequence>
                        <timer duration="timeout">
                            <loop>
                                <sequence>
                                    <stafcmd>
                                        <location>machine</location>
                                        <service>'fs'</service>
                                        <request>'get entry %s size' % outputFile[0]</request>
                                    </stafcmd>
                                    <script>
                                        import time
                                        if RC == STAFRC.Ok:
                                           if (maxSize[0] &lt; 0) or (int(STAFResult['lowerSize']) &lt; maxSize[0]):
                                              sizeExceeded[0] = 0
                                           else:
                                              sizeExceeded[0] = 1
                                           lastSize[0] = STAFResult['lowerSize']
                                    </script>
                                    <if expr="sizeExceeded[0] != 0">
                                        <sequence>
                                            <log>'terminate block, maxSize exceeded=%s'%lastSize[0]</log>
                                            <terminate block="'main.' + installBlock"/>
                                        </sequence>
                                    </if>
                                    <stafcmd name="'Sleep 10 seconds'">
                                        <location>machine</location>
                                        <service>'DELAY'</service>
                                        <request>'DELAY 10000'</request>
                                    </stafcmd>

                                </sequence>
                            </loop>
                        </timer>
			<log>'terminate block anyway'</log>
			<script>zmsetupError[0] = 1</script>
                        <terminate block="'main.' + installBlock"/>
                    </sequence>
                </parallel>
            </block>
            <!--if expr="sizeExceeded[0] != 0">
                <process name="'Truncate log - ' + machine">
                    <location>machine</location>
                    <command>'/bin/env'</command> 
                    <workdir>'/opt/zimbra'</workdir>
                    <parms>'ruby -e "File.truncate(\'%s\', 10000)"'%outputFile[0]</parms> 
                    <stdout mode="'append'">outputFile[0]</stdout>
                    <stderr mode="'stdout'"/>
                    <returnstdout/>
                </process>
            </if-->                
            <script>
                if zmsetupError[0] or sizeExceeded[0]:
                   res= failed
                else:
                   res = passed
            </script>
            <if expr= "zmsetupError[0] or sizeExceeded[0]">
                <process name="'Append error message'">
                    <location>machine</location>
                    <command>'/bin/echo'</command>
                    <workdir>'/tmp'</workdir>
                    <parms>'\nerror zmsetup error=%s, timeout exceeded, or log size exceeded, last size=%s\n' % (zmsetupError[0], lastSize[0])</parms>
                    <stdout mode="'append'">outputFile[0]</stdout>  
                </process>
            </if>
            <log>'zmsetup complete on %s, res %s, log=%s.' % (machine, res, outputFile[0])</log>
            <return>res</return>
        </sequence>
    </function>

    <function name="installLicense" scope="local">
        <function-prolog>
            This function install a new license key
        </function-prolog>

        <function-map-args>
            <function-required-arg name="machine">
                Name of the target machine
            </function-required-arg>

            <function-optional-arg name="outputFile" default="'/tmp/install.out'">
                Stdout file
            </function-optional-arg>

        </function-map-args>

        <sequence>
            <script>
                licenseFile='/opt/zimbra/conf/ZCSLicense.xml'
            </script>

            <call function="'getLicense'">
                {'machine':machine,
                 'outputFile':outputFile}
            </call>

            <process name="'Install license'">
                <location>machine</location>
                <command mode="'shell'">'su - zimbra -c "zmlicense -i %s"'%licenseFile</command>
                <workdir>'/opt/zimbra/bin'</workdir>
                <stdout mode="'append'">outputFile</stdout>
                <stderr mode="'stdout'"/>
            </process>

            <!-- bugs 9668/10357 workaround: restart tomcat -->
            <process name="'Tomcat status'">
                <location>machine</location>
                <command mode="'shell'">'su - zimbra -c "tomcat status"'</command>
                <workdir>'/opt/zimbra/bin'</workdir>
                <stdout mode="'append'">outputFile</stdout>
                <stderr mode="'stdout'"/>
            </process>

            <if expr="RC == STAFRC.Ok">
                <sequence>
                    <process name="'stop zimbra'">
                        <location>machine</location>
                        <command mode="'shell'">'su - zimbra -c "zmcontrol stop"'</command>
                        <workdir>'/opt/zimbra/bin'</workdir>
                        <stdout mode="'append'">outputFile</stdout>
                        <stderr mode="'stdout'"/>
                        <!--returnstdout/-->
                    </process>
                    <process name="'start zimbra'">
                        <location>machine</location>
                        <command mode="'shell'">'su - zimbra -c "zmcontrol start"'</command>
                        <workdir>'/opt/zimbra/bin'</workdir>
                        <stdout mode="'append'">outputFile</stdout>
                        <stderr mode="'stdout'"/>
                        <!--returnstdout/-->
                    </process>
                </sequence>
            </if>

            <!--process name="'Tomcat restart'">
                <location>machine</location>
                <command mode="'shell'">'su - zimbra -c "tomcat restart"'</command>
                <workdir>'/opt/zimbra/bin'</workdir>
                <stdout mode="'append'">outputFile</stdout>
                <stderr mode="'stdout'"/>
            </process-->

            <process name="'Append message'">
                <location>machine</location>
                <command>'/bin/echo'</command>
                <workdir>'/tmp'</workdir>
                <parms>'Current zimbra license:\n'</parms>
                <stdout mode="'append'">outputFile</stdout>  
            </process>

            <process name="'Print license'">
                <location>machine</location>
                <command mode="'shell'">'su - zimbra -c "zmlicense -p"'</command>
                <workdir>'/opt/zimbra/bin'</workdir>
                <stdout mode="'append'">outputFile</stdout>
                <stderr mode="'stdout'"/>
            </process>

            <log>'install License complete on %s, RC %s' % (machine, RC)</log>
            <return>RC</return>
        </sequence>
    </function>

    <function name="fixRedolog" scope="local">
        <function-prolog>
            This function is used to set proper redolog access permission
        </function-prolog>
        <function-map-args>
        <function-required-arg name="machine">
            Target machine
        </function-required-arg>
        <function-optional-arg name="outputFile" default="'/tmp/install.out'">
            Stdout file
        </function-optional-arg>
        </function-map-args>

        <sequence>
            <stafcmd>
                <location>machine</location>
                <service>'fs'</service>
                <request>'query entry /etc/debian_version'</request>
            </stafcmd>
            <if expr="RC == 0">
                <sequence>
                    <log>'Patch Debian for redolog permission issue'</log>
                    <script>cmd = 'zmmailboxctl'</script>
                    <stafcmd>
                        <location>machine</location>
                        <service>'fs'</service>
                        <request>'query entry /opt/zimbra/bin/%s' % cmd</request>
                    </stafcmd>
                    <if expr="RC != STAFRC.Ok">
                        <!-- mbs not installed on this machine -->
                        <return/>
                    </if>
                    <process name="'stop webserver - ' + machine">
                        <location>machine</location>
                        <command mode="'shell'">'su - zimbra -c "%s stop"' % cmd</command>
                        <workdir>'/tmp'</workdir>
                        <stdout mode="'append'">outputFile</stdout>
                        <stderr mode="'stdout'"/>
                    </process>
                    <process name="'Chown redolog - ' + machine">
                        <location>machine</location>
                        <command>'/bin/chown'</command>
                        <workdir>'/tmp'</workdir>
                        <parms>'zimbra:zimbra /opt/zimbra/redolog/redo.log'</parms>
                        <stdout mode="'append'">outputFile</stdout>
                        <stderr mode="'stdout'"/>
                    </process>
                    <process name="'start webserver  - ' + machine">
                        <location>machine</location>
                        <command mode="'shell'">'su - zimbra -c "%s start"' % cmd</command>
                        <workdir>'/tmp'</workdir>
                        <stdout mode="'append'">outputFile</stdout>
                        <stderr mode="'stdout'"/>
                    </process>
                </sequence>
            </if>
            <return/>
        </sequence>
    </function>

    <function name="getLicense" scope="local">
        <function-prolog>
            This function gets a new /opt/zimbra/conf/ZCSLicense.xml
        </function-prolog>

        <function-map-args>
            <function-required-arg name="machine">
                Name of the target machine
            </function-required-arg>
            <function-optional-arg name="licenseFile" default="'/opt/zimbra/conf/ZCSLicense.xml'">
                Stdout file
            </function-optional-arg>
            <function-optional-arg name="outputFile" default="'/tmp/install.out'">
                Stdout file
            </function-optional-arg>

        </function-map-args>

        <sequence>
            <script>
                import time
                now = time.localtime(time.time())
                #validFrom=time.strftime("%m/%d/%Y", now)
                postData = "AccountsLimit=-1"
                postData += "&amp;ValidFrom=" + time.strftime("%m/%d/%Y", now)
                postData += "&amp;InstallType=regular"
                postData += "&amp;IssuedToEmail=qa@zimbra.com"
                postData += "&amp;ArchivingAccountsLimit=-1"
                postData += "&amp;AttachmentIndexingAccountsLimit=-1"
                postData += "&amp;MAPIConnectorAccountsLimit=-1"
                postData += "&amp;MobileSyncAccountsLimit=-1"
                postData += "&amp;SMIMEAccountsLimit=-1"
                postData += "&amp;VoiceAccountsLimit=-1"
                postData += "&amp;EwsAccountsLimit=-1"
                postData += "&amp;TouchClientsAccountsLimit=-1"
                postData += "&amp;ZSSAccountsLimit=-1"
                postData += "&amp;ver=2.3"
            </script>

            <script>
                qa00LicenseURL='http://' + gMachines['tms'] + '/license/ZCSLicense.xml'
                buildLicenseURL='http://' + gMachines['build'] + '/zimbraLicensePortal/QA/LKManager'
                #licenseURL='http://10.10.131.19:7070/zimbraLicensePortal/QA/LKManager'
                licenseSource='build portal'
                #licenseFile='/opt/zimbra/conf/ZCSLicense.xml'
            </script>

            <timer duration="'1m'">
                <sequence>
                <script>exitCode=STAFRC.DoesNotExist</script>
                <process name="'Get License from build'">
                    <location>machine</location>
                    <command>'wget'</command>         
                    <workdir>'/tmp'</workdir>     
                    <parms>'--no-proxy -O %s  --quiet --no-check-certificate --post-data="%s" %s'%(licenseFile, postData, buildLicenseURL)</parms>         
                    <stdout mode="'append'">outputFile</stdout>
                    <stderr mode="'stdout'"/>
                </process>
                <script>exitCode=RC</script>
                </sequence>
            </timer>

            <if expr="(RC != STAFRC.Ok) or (exitCode != STAFRC.Ok)">
                <sequence>
                    <process name="'Get License from qa00'">
                        <location>machine</location>
                        <command>'wget'</command>         
                        <workdir>'/tmp'</workdir>     
                        <parms>'--no-proxy -O %s --quiet --no-check-certificate %s'%(licenseFile, qa00LicenseURL)</parms>         
                        <stdout mode="'append'">outputFile</stdout>
                        <stderr mode="'stdout'"/>
                    </process>
                    <script>licenseSource='tms'</script>
                </sequence>
            </if>

            <stafcmd>
                <location>machine</location>
                <service>'fs'</service>
                <request>'get file ' + licenseFile</request>
            </stafcmd>
            <script>res=STAFResult</script>
            <process name="'chmod 644 - ' + machine">
                <location>machine</location>
                <command>'/bin/env'</command>
                <workdir>'/tmp'</workdir>
                <parms>'chmod 644 %s'%licenseFile</parms>
                <stdout mode="'append'">outputFile</stdout>
                <stderr mode="'stdout'"/>
            </process>
            <process name="'Append message'">
                <location>machine</location>
                <command>'/bin/echo'</command>
                <workdir>'/tmp'</workdir>
                <parms>'Received new license from %s:\n%s'% (licenseSource, res)</parms>
                <stdout mode="'append'">outputFile</stdout>  
            </process>

        </sequence>
    </function>

    <function name="enableRemoteLogging" scope="local">
        <function-prolog>
            This function 
        </function-prolog>
        <function-map-args>
            <function-required-arg name="machine">
                Logger host
            </function-required-arg>
            <function-required-arg name="OS">
                Target OS
            </function-required-arg>
        </function-map-args>

        <sequence>
            <!-- REWORK needed:
                 1) if rsyslog, then in /etc/rsyslog.conf uncomment the following lines
                      $ModLoad imudp
                      $UDPServerRun 514
                 2) else use the current way
                 3) then run zmsyslogsetup
            -->
            <script>cfgFile = '/etc/sysconfig/syslog'</script>
            <stafcmd>
                <location>machine</location>
                <service>'FS'</service>
                <request>'query entry ' + cfgFile</request>
            </stafcmd>
            <if expr="RC != STAFRC.Ok">
                <sequence>
                    <script>cfgFile = '/etc/default/syslogd'</script>
                    <stafcmd>
                        <location>machine</location>
                        <service>'FS'</service>
                        <request>'query entry ' + cfgFile</request>
                    </stafcmd>
                </sequence>
            </if>
            <if expr="RC == STAFRC.Ok">
                <sequence>
                    <stafcmd>
                        <location>machine</location>
                        <service>'fs'</service>
                        <request>'COPY FILE %s TOFILE /tmp/sconf.txt TOMACHINE %s'%(cfgFile, STAXServiceMachineNickname)</request>
                    </stafcmd>
                    <script>
                        import re
                        f = open('/tmp/sconf.txt')
                        lines = f.readlines()
                        f.close()
                        update = 0
                        for i in range(len(lines)):
                           line = lines[i]
                           if line.find('SYSLOGD_OPTIONS') == 0 or line.find('SYSLOG_NG_PARAMS') == 0:
                              tokens = line.split('=')
                              if tokens[1].find('-r ') == -1:
                                 repl = tokens[1][0:0] + '"-r ' + tokens[1][1:]
                                 lines[i] = tokens[0] + '=' + repl
                                 update = 1
                                 break
                        if update == 1:
                           f = open('/tmp/sconf.txt', 'w')
                           f.writelines(lines)
                           f.close()
                    </script>
                    <stafcmd>
                        <location>STAXServiceMachineNickname</location>
                        <service>'fs'</service>
                        <request>'COPY FILE /tmp/sconf.txt TOFILE %s TOMACHINE %s'%(cfgFile, machine)</request>
                    </stafcmd>
                    <script>
                        if OS.startswith('DEBIAN') or OS.startswith('UBUNTU'):
                           cmd = '/etc/init.d/sysklogd'
                        elif OS.startswith('MACOSX'):
                           #stopCmd = 'service com.apple.syslogd stop; killall -TERM syslogd'
                           #startCmd = 'sudo syslogd -m 0 -u &amp;'
                           cmd = 'not_implemented'
                        else:
                           cmd = '/etc/init.d/syslog'
                    </script>
                    <process name="'Stop syslog - ' + machine">
                        <location>machine</location>
                        <command>cmd</command>
	                <workdir>'/var/log'</workdir>
                        <parms>'stop'</parms>
                    </process>
                    <process name="'Start syslog - ' + machine">
                        <location>machine</location>
                        <command>cmd</command>
	                <workdir>'/var/log'</workdir>
                        <parms>'start'</parms>
                    </process>
                </sequence>
            </if>
        </sequence>
    </function>

    <function name="getPlatform" scope="local">
        <function-prolog>
            This function returns the OS name
        </function-prolog>
        <function-list-args>
            <function-required-arg name="machine">
                Name of the target machine
            </function-required-arg>
        </function-list-args>
        <sequence>
            <script>cmd = '/opt/zimbra/libexec/get_plat_tag.sh'</script>
            <stafcmd>
                <location>machine</location>
                <service>'fs'</service>
                <request>'query entry %s' % cmd</request>
            </stafcmd>
            <if expr="RC != STAFRC.Ok">
                <sequence>
                    <script>cmd = '/opt/zimbra/bin/get_plat_tag.sh'</script>
                    <stafcmd>
                        <location>machine</location>
                        <service>'fs'</service>
                        <request>'query entry %s' % cmd</request>
                    </stafcmd>
                    <if expr="RC != STAFRC.Ok">
                        <sequence>                    
                            <return>None</return>
                        </sequence>
                    </if>
                </sequence>
            </if>
            <process name="'Get platform - ' + machine">
                <location>machine</location>
                <command>cmd</command>
                <workdir>'/opt/zimbra'</workdir>
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
                <returnstdout/>
            </process>
            <if expr="RC != STAFRC.Ok">
                <sequence>                    
                    <return>None</return>
                </sequence>
            </if>
            <script>
                import re
                platform = STAXResult[0][1].strip().replace('\n', '')
            </script>
            <return>platform</return>
        </sequence>
    </function>

    <function name="masqueradeURL" scope="local">
    
        <function-prolog>
            Configure URL as local
        </function-prolog>
        
        <function-map-args>
                
            <function-required-arg name="machine">
                Name of the target machine
            </function-required-arg>

            <function-required-arg name="URL">
                URL to masquerade
            </function-required-arg>

        </function-map-args>
        
        <sequence>
            <call function="'getPlatform'">machine</call>
            <if expr = "(STAXResult is not None) and (STAXResult.find('MACOSX') == -1)">
                <sequence>
                    <!-- check /etc/nsswitch.conf -->
                    <script>
                        file = '/etc/nsswitch.conf'
                        rex = ['^hosts:\s+files dns.*']
                    </script>
                </sequence>
                <else>
                    <sequence>
                        <process name="'lookupd configuration - ' + machine">
                            <location>machine</location>
                            <command>'/bin/bash'</command>
                            <workdir>'/tmp'</workdir>
                            <parms>'-l -c "lookupd -configuration | tr -d \\\"\n\\\" &gt; /tmp/nsswitch.conf'</parms>
                            <stdout>'/tmp/nsswitch.conf'</stdout>
                            <stderr mode="'stdout'"/>
                            <!--returnstdout/-->
                        </process>
                        <script>
                            file = '/tmp/nsswitch.conf'
                            rex = ['LookupOrder: (Cache)? FF(( DNS| NI| DS)?){0,3}_config_name: Network Configuration.*']
                        </script>
                    </sequence>
                </else>
            </if>
            <call function="'checkConfig'">
                {'machine': machine,
                 'file'   : file,
                 'requirements': rex
                }
            </call>
            <if expr="STAXResult != 0">
                <sequence>
                   <log>'need to configure %s:%s' % (machine, file)</log>
                </sequence>
                <else>
                   <log>'%s:%s configured' % (machine, file)</log>
                </else>
            </if>

            <!-- check /etc/hosts -->
            <script>file = '/etc/hosts'</script>
            <process name="'find ip address - ' + machine">
                <location>machine</location>
                <command>'host'</command>
                <parms>machine</parms>
                <returnstdout/>
            </process>
            <script>ip = STAXResult[0][1].split(' ')[-1].replace('\n','')</script>
            <call function="'checkConfig'">
                {'machine': machine,
                 'file'   : file,
                 'requirements': ['^%s\s+%s.*' % (ip, URL)]
                }
            </call>
            <if expr="STAXResult == 0">
                <sequence>
                    <log>'%s:%s configured' % (machine, file)</log>
                    <return>[0, 'configured']</return>
                </sequence>
            </if>
            <log>'configure %s:%s' % (machine, file)</log>
            <!-- config /etc/hosts -->
            <process name="'save ' + file + ' - ' + machine">
                <location>machine</location>
                <command>'/bin/bash'</command> 
                <workdir>'/etc'</workdir>
                <parms>'-l -c "cp -pf %s %s.bak"' % (file, file)</parms> 
                <!--stdout mode="'append'">outputFile[0]</stdout-->
                <stderr mode="'stdout'"/>
                <returnstdout/>
            </process>
            <if expr="RC != STAFRC.Ok">
                <sequence>
                    <script>
                        rc = RC
                        msg = 'warning fail to backup %s:%s - %s' % (machine, file, STAXResult[0][1])
                    </script>
                    <log>msg</log>
                    <return>[rc, msg]</return>
                </sequence>
            </if>
            <process name="'modify ' + file + ' - ' + machine">
                <location>machine</location>
                <command>'/bin/bash'</command>
                <workdir>'/etc'</workdir>
                <parms>'-l -c "echo \\\"%s\t\t%s\\\" &gt;&gt; %s' % (ip, URL, file)</parms>
                <stdout mode="'append'">'/tmp/replaceMe.ksh'</stdout>
                <stderr mode="'stdout'"/>
                <returnstdout/>
            </process>
  <log>'echo res=%s, out=%s'%(RC, STAXResult)</log>
            <return>[RC, STAXResult[0][1]]</return>
        </sequence>
    </function>

    <function name="unmasqueradeURL" scope="local">
    
        <function-prolog>
            Un-Configure URL
        </function-prolog>
        
        <function-map-args>
                
            <function-required-arg name="machine">
                Name of the target machine
            </function-required-arg>

            <function-required-arg name="URL">
                URL to masquerade
            </function-required-arg>

        </function-map-args>
        
        <sequence>
            <script>file = '/etc/hosts'</script>
            <process name="'find ip address - ' + machine">
                <location>machine</location>
                <command>'host'</command>
                <parms>machine</parms>
                <returnstdout/>
            </process>
            <script>ip = STAXResult[0][1].split(' ')[-1].replace('\n','')</script>
            <call function="'checkConfig'">
                {'machine': machine,
                 'file'   : file,
                 'requirements': ['^#*%s\s+%s.*$' % (ip, URL)]
                }
            </call>
            <if expr="STAXResult != 0">
                <sequence>
                    <log>'%s:%s is clean' % (machine, file)</log>
                    <return>[0, '']</return>
                </sequence>
            </if>
            <log>'cleanup %s:%s' % (machine, file)</log>
            <!-- config /etc/hosts -->
            <process name="'update ' + file + ' - ' + machine">
                <location>machine</location>
                <command>'sed'</command> 
                <workdir>'/etc'</workdir>
                <parms>'-i.stax -e "/^#*%s.*%s.*$/d" %s' % (ip, URL, file)</parms> 
                <stderr mode="'stdout'"/>
                <returnstdout/>
            </process>
            <if expr="RC != STAFRC.Ok">
                <sequence>
                    <script>
                        rc = RC
                        msg = STAXResult[0][1]
                    </script>
                    <process name="'restore ' + file + ' - ' + machine">
                        <location>machine</location>
                        <command>'mv'</command> 
                        <workdir>'/etc'</workdir>
                        <parms>'%s.stax %s' % (file, file)</parms> 
                        <!--stdout mode="'append'">outputFile[0]</stdout-->
                        <!--stderr mode="'stdout'"/>
                        <returnstdout/-->
                    </process>
                    <return>[rc, msg]</return>
                </sequence>
            </if>
            <return>[RC, '']</return>
        </sequence>
    </function>

    <function name="checkConfig" scope="local">
    
        <function-prolog>
            Check a file against a required config list
            the list contains re strings
        </function-prolog>
        
        <function-map-args>
                
            <function-required-arg name="machine">
                Name of the target machine
            </function-required-arg>

            <function-required-arg name="file">
                Name of the target machine
            </function-required-arg>

            <function-required-arg name="requirements">
                List of configs
            </function-required-arg>

        </function-map-args>
        
        <sequence>
            <script>STAXMessageLog=1</script>
<log>'checkconfig(machine=%s,file=%s,reqs=%s)' % (machine, file, requirements)</log>
            <!-- check /etc/nsswitch.conf -->
            <stafcmd>
                <location>machine</location>
                <service>'fs'</service>
                <request>'GET FILE %s' % file</request>
            </stafcmd>
            <if expr="RC != STAFRC.Ok">
                <sequence>
                   <log>'Error reading %s RC=%s' % (file, RC)</log>
                   <return>RC</return>
                </sequence>
            </if>
            <script>
                import re
                config = STAFResult.split('\n')
                missing = []
                needsConfig = 0
                for req in requirements:
                   rex = re.compile(req)
                   found = 0
                   for line in config:
                      match = re.search(rex, line)
                      if match != None:
                         found = 1
                         l = line
                         break
                   if found == 0:
                      needsConfig = 1
                      missing.append(req)
            </script>
            <return>needsConfig</return>
        </sequence>
    </function>

    <function name="safeInvoke" scope="local">
        <function-prolog>
            This function executes a function call
            The termination is guaranteed(either success or timeout)
        </function-prolog>
        <function-map-args>
            <function-required-arg name="functionToInvoke">
                Name of the target function
            </function-required-arg>
            <function-required-arg name="functionArguments">
                Function arguments
            </function-required-arg>
            <function-optional-arg name="timeout" default="'10m'">
                Default timeout
            </function-optional-arg>        
        </function-map-args>
        <sequence>
            <log level="'debug'">'called %s(%s, timeout=%s)' % (functionToInvoke, functionArguments, timeout)</log>
            <script>
                from java.lang import String
                from java.lang import System

                invokeError = STAXGlobal([0])
                timeoutError = STAXGlobal([0])
                #watchdogBlock = 'watchdog.safe'
                details = STAXGlobal([0])
                watchdogBlock = 'watchdogBlock.' + String.valueOf(System.currentTimeMillis())
            </script>
            <block name="watchdogBlock">
                <sequence>
                    <timer duration="timeout">
                        <sequence>
                            <call function="functionToInvoke">functionArguments</call>
                            <log>'%s STAXResult=%s' % (functionToInvoke, STAXResult)</log>
                            <script>
                                invokeError[0] = STAXResult[0]
                                details[0] = STAXResult[1]
                            </script>
                            <terminate/>
                        </sequence>
                    </timer>
	                <log>'terminate block anyway'</log>
		            <script>timeoutError[0] = STAFRC.Timeout</script>
                    <terminate/>
                </sequence>
            </block>
            <script>
                if invokeError[0]:
                    res = invokeError[0]
                elif timeoutError[0]:
                    res = timeoutError[0]
                else:
                    res = STAFRC.Ok
            </script>
            <log level="'debug'">'Completed execution of %s, result=[%s,%s]' % (functionToInvoke, res, details[0])</log>
            <return>[res, details[0]]</return>
        </sequence>
    </function>

    <function name="getLogs" scope="local">
        <function-prolog>
            This function returns a list with log files to be archived
        </function-prolog>
        <function-map-args>
            <function-required-arg name="buildProps">
                Build
            </function-required-arg>
            <function-required-arg name="machine">
                hostname
            </function-required-arg>
        </function-map-args>
        <sequence>
            <script>
                s=buildProps['build']
                logList = ['/var/log/zimbra.log',
                           '/tmp/install.out.' + s,
                           '/opt/zimbra/db/data/' + machine + '.err',
                           '/opt/zimbra/log/zimbra.log',
                           '/opt/zimbra/log/mailbox.log',
                           '/opt/zimbra/log/zmmailboxd.out',
                           '/opt/zimbra/log/sqlMigration.log',
                           '/opt/zimbra/log/logger_mysql_error.log',
                           '/opt/zimbra/log/mysql_error.log',
                           '/opt/zimbra/.install_history',
                           '/opt/zimbra/log/convertd.out',
                           '/opt/zimbra/log/convertd.log',
                          ]
            </script>
            <process name="'find zmsetup log - ' + machine">
                <location>machine</location>
                <command>'/bin/bash'</command> 
                <workdir>'/tmp'</workdir>
                <parms>'-l -c "ls -rt1 /opt/zimbra/log/zmsetup*.[tl][xo][tg] | tail -1"'</parms>
                <stderr mode="'stdout'"/>
                <returnstdout/>
	        </process>
            <script>logList.append(STAXResult[0][1].replace('\n',''))</script>
            <process name="'find install.log - ' + machine">
                <location>machine</location>
                <command>'/bin/bash'</command> 
                <workdir>'/tmp'</workdir>
                <parms>'-l -c "ls -rt1 /tmp/install.log.* | tail -1"'</parms>
                <stderr mode="'stdout'"/>
                <returnstdout/>
	        </process>
            <script>
                if RC == STAFRC.Ok:
                  logList.append(STAXResult[0][1].replace('\n',''))
            </script>
            <return>logList</return>
        </sequence>
    </function>

    <function name="updateHistory" scope="local">
        <function-prolog>
            This function returns a list with log files to be archived
        </function-prolog>
        <function-map-args>
            <function-required-arg name="buildName">
                Build
            </function-required-arg>
            <function-required-arg name="machine">
                hostname
            </function-required-arg>
        </function-map-args>
        <sequence>
            <script>
                import os
                name = os.path.basename(buildName)
                name = name[0:name.rfind('.')]
                historyFile = '/opt/zimbra/.update_history'
                tmpFile = '/tmp/%s.historyfile.txt' % machine
                history = ""
            </script>
            <stafcmd>
                <location>machine</location>
                <service>'fs'</service>
                <request>'GET FILE %s' % historyFile</request>
            </stafcmd>
            <if expr="RC == STAFRC.Ok">
                <script>
                    history = STAFResult.replace('\n','')
                </script>
            </if> 
            <script>
                import os
                f = open(tmpFile, 'w')
                f.write(history + name + "|\n")
                f.close()
            </script>
            <stafcmd>
                <location>'local'</location>
                <service>'fs'</service>
                <request>'COPY FILE %s TOFILE %s TOMACHINE %s TEXT' % (tmpFile, historyFile, machine)</request>
            </stafcmd>
            <return>[RC, 'COPY FILE %s TOFILE %s TOMACHINE %s TEXT' % (tmpFile, historyFile, machine)]</return>
        </sequence>
    </function>

    <function name="buildParser" scope="local">
        <function-prolog>
            This function 
        </function-prolog>
        <function-map-args>
            <function-required-arg name="buildName">
                Name
            </function-required-arg>
            <function-required-arg name="OS">
                Name
            </function-required-arg>
        </function-map-args>

        <sequence>
            <script>
                import re
                match=re.search('.*_%s_(.*)_((\d{14,})_.*)\.\S{3,}'%OS, buildName)
            </script>
            <return>{'branch':match.group(1), 'build':match.group(2), 'timestamp':match.group(3)}</return>
        </sequence>
    </function>

    <function name="preExecution" scope="local">
        <function-prolog>
            
        </function-prolog>
        <function-list-args>
            <function-required-arg name="plan">
                Test -plan
            </function-required-arg>
        </function-list-args>

        <sequence>
            <signalhandler signal="'STAXFunctionDoesNotExist'">
                <sequence>
                    <log message="1" level="'Error'">
                        'STAXFunctionDoesNotExist signal raised.%s' % \
                        (STAXFunctionDoesNotExistMsg)
	            </log>
                    <throw exception="'STAXFunctionDoesNotExist'"/>
                </sequence>
            </signalhandler>

            <call function="'parseXML'">plan</call>
            <script>
                document = STAXResult
                #make it global
                preExec = document.getElementsByTagName("preexecution")
                if preExec.getLength() != 0:
                   drivers = preExec.item(0).getElementsByTagName("driver")
            </script>
            <if expr="(preExec.getLength() == 0) or (drivers.getLength() == 0)">
                <return>[STAFRC.Ok, 'No preexecution steps/drivers']</return>
            </if>
            <iterate var="idx" in="range(drivers.getLength())">
                <sequence>
                    <try>
                        <sequence>
                            <script>
                                args = {}
                                options = drivers.item(idx).getElementsByTagName("option")
                                for i in range(options.getLength()):
                                  option = options.item(i)
                                  args[option.getAttributes().getNamedItem('name').getNodeValue()] = option.getFirstChild().getNodeValue().strip().replace('\n', '')
                            </script>
                            <call function="drivers.item(idx).getAttributes().getNamedItem('name').getNodeValue()">args</call>
                            <!--call function="drivers.item(idx).getAttributes().getNamedItem('name').getNodeValue()">drivers.item(idx).getAttributes().getNamedItem('host').getNodeValue()</call-->
                        </sequence>
                        <catch exception="'STAXFunctionDoesNotExist'">
                            <sequence>
                                <log>'Driver not supported - %s'%drivers.item(idx).getAttributes().getNamedItem('name').getNodeValue()</log>
                                <return>[STAFRC.Ok, 'Driver not supported - %s'%drivers.item(idx).getAttributes().getNamedItem('name').getNodeValue()]</return>
                            </sequence>
                        </catch>
                    </try>
                </sequence>
            </iterate>
            <return>[STAFRC.Ok, 'preexecution completed']</return>
        </sequence>
    </function>

    <function name="archivingAndDiscovery" scope="local">
        <function-prolog>
            
        </function-prolog>
        <function-map-args>
            <function-required-arg name="parameters">
                arguments hash
            </function-required-arg>
        </function-map-args>

        <sequence>

            <log level = "'info'">'archivingAndDiscovery(%s)'%parameters['host']</log>
            <process name="'Untar - ' + parameters['host'][0]">
                <location>parameters['host'][0]</location>
                <command>'tar'</command>
                <workdir>'/opt/zimbra'</workdir>
                <parms>'-xzf %s' % '/var/tmp/zimbra-archiving.tgz'</parms>  
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
                <!--returnstdout/-->
            </process>      
            <log>'untar %s in %s on %s, RC=%s, res=%s' % ('/var/tmp/zimbra-archiving.tgz', '/opt/zimbra', parameters['host'][0], RC, STAXResult)</log>
            <process name="'deploy xmbxsearch - ' + parameters['host'][0]">
                <location>parameters['host'][0]</location>
                <command mode="'shell'">'su - zimbra -c "zmzimletctl deploy zimlets-network/zimbra_xmbxsearch.zip;zmcontrol stop;zmcontrol start"'</command>
                <workdir>'/opt/zimbra'</workdir>
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
                <!--returnstdout/-->
            </process>
        </sequence>
    </function>

    <function name="createYahooAccounts" scope="local">
        <function-prolog>
            
        </function-prolog>
        <function-map-args>
            <function-required-arg name="parameters">
                
            </function-required-arg>
        </function-map-args>

        <sequence>
            <log level = "'info'">'createYahooAccounts(%s)'%parameters['host']</log>
            <call function="'runGenesis'">
                        {'machine' : parameters['host'][0],
                         'OS' : OS,
                         'build' : build,
                         'branch' : branch,
                         'timestamp' : timestamp,
                         'notificationAlias' : notificationAlias,
                         'plan' : 'yahoo',
                         'needNotify' : '0',
                         'needSetUp' : needSetUp,
                         'tms': gMachines['tms'],
                         'tmsStax' : gMachines['tmsStax']
                        }
            </call>
        </sequence>
    </function>
    
    <function name="runGenesisTests" scope="local">
        <function-prolog>
            
        </function-prolog>
        <function-map-args>
            <function-required-arg name="parameters">
                
            </function-required-arg>
        </function-map-args>

        <sequence>
            <log level = "'info'">'runGenesisTests(%s)'%parameters</log>
            <script>
                missing = []
                for p in ['host', 'test']:
                  if p in parameters.keys():
                    continue
                  missing.append(p)
            </script>
            <if expr="len(missing) != 0">
                <return>[STAFRC.DoesNotExist, 'plugin runGenesisTests missing option(s) %s.'%[','].join(missing)]</return>
            </if>
            <script>
                #generate /tmp/testplan.txt
                plan = ""
                for i in range(len(parameters['test'])):
                  crt = parameters['test'][i] + "\n"
                  if crt.find('data') != 0:
                    crt = "data/" + crt
                  plan += crt
            </script>
            <log level = "'info'">'plan=%s.'%plan</log>
            <process name="'Create test plan - ' + parameters['host'][0]">
                <location>parameters['host'][0]</location>
                <command>'/bin/echo'</command>
                <workdir>'/tmp'</workdir>
                <parms>'%s' % plan</parms>
                <stdout>'/tmp/testplan.txt'</stdout>
                <returnstdout/>
                <returnstderr/>
            </process>
            <log>'echo res=%s, out=%s'%(RC, STAXResult)</log> 
            <!--call function="'runGenesis'">
                {'machine' : parameters['host'][0],
                 'OS' : OS,
                 'build' : build,
                 'branch' : branch,
                 'timestamp' : timestamp,
                 'notificationAlias' : notificationAlias,
                 'plan' : '/tmp/testplan.txt',
                 'needNotify' : '0',
                 'needSetUp' : needSetUp,
                 'tms': gMachines['tms'],
                 'tmsStax' : gMachines['tmsStax']
                }
            </call-->
            <script>
                # -r http://zqa-004.eng.vmware.com/qa/HELIX/genesis/ -P /opt/qa  --no-proxy --level=0 - --waitretry=1 --tries=0 -q -nH -np -R index.html --cut-dirs=2
                wgetparams = '-r http://'
                wgetparams += gMachines['tms']
                wgetparams += '/qa/'
                wgetparams += branch
                wgetparams += '/genesis/ -P /opt/qa  --no-proxy --level=0 -'
                wgetparams += ' --waitretry=1 --tries=0 -q -nH -np -R index.html --cut-dirs=2'
                logDir = '/opt/qa/testlogs'
                logDir += '/' + OS + '/' + branch + '/' + build
                logDir += '/genesis/' + timestamp
                logDir += '/' + parameters['host'][0] + '/'
            </script>
            <call function="'runCommand'">
                {'machine' : parameters['host'][0],
                 'pCommand' : 'wget',
                 'pWorkDir' : '.',
                 'pParams' : wgetparams,
                 #'pjobID' : pjobID,
                 'tms': gMachines['tms'],
                 'tmsStax' : gMachines['tmsStax']
                }
            </call>
            <call function="'runCommand'">
                {'machine' : parameters['host'][0],
                 'pCommand' : '/bin/env',
                 'pWorkDir' : '.',
                 'pParams' : 'mkdir -p ' + logDir,
                 #'pjobID' : pjobID,
                 'tms': gMachines['tms'],
                 'tmsStax' : gMachines['tmsStax']
                }
            </call>
            <call function="'runCommand'">
                {'machine' : parameters['host'][0],
                 'pCommand' : '/bin/env',
                 'pWorkDir' : '/opt/qa/genesis',
                 'pParams' : 'ruby runtest.rb --plan /tmp/testplan.txt --log ' + logDir,
                 'resultFile' : logDir + 'summary.txt',
                 'tms': gMachines['tms'],
                 'tmsStax' : gMachines['tmsStax']
                }
            </call>
        </sequence>
    </function>
    
	<function name="enableConvertd" scope="local">
        <function-prolog>
            
        </function-prolog>
        <function-map-args>
            <function-required-arg name="parameters">
                param hash
            </function-required-arg>
        </function-map-args>

        <sequence>
            <log level = "'info'">'enableConvertd(%s)'%parameters</log>
            <!-- no longer needed in main/GNR -->
            <return>[STAFRC.Ok, 'only the new convertd is available']</return>
            <script>
                su = 'su - zimbra '
                if OS.startswith('MACOSXx86_10.5'):
                  su += '-l '
                su += '-c '
                missing = []
                for p in ['host', 'version']:
                  if p in parameters.keys():
                    continue
                  missing.append(p)
            </script>
            <if expr="len(missing) != 0">
                <return>[STAFRC.DoesNotExist, 'driver enableConvertd missing option(s) %s.'%[','].join(missing)]</return>
            </if>
            <process name="'get convertd version - ' + parameters['host'][0]">
                <location>parameters['host'][0]</location>
                <command mode="'shell'">'%s "zmlocalconfig convertd_version"'%su</command>
                <workdir>'/opt/zimbra'</workdir>
                <stdout>'/tmp/convertd.out'</stdout>
                <stderr mode="'stdout'"/>
                <returnstdout/>
            </process>
            <log>'RC=%s,res=%s.'%(RC, STAXResult[0][1])</log>
            <if expr="RC==STAFRC.Ok and STAXResult[0][1].find(parameters['version'][0].replace('v', '')) != -1">
                <return>[RC, 'convertd %s already running'%parameters['version'][0]]</return>
            </if>
            <script>
                cmd = '/opt/zimbra/bin/zmconvertctl stop;/opt/zimbra/convertd/bin/'
                if parameters['version'][0] == 'v2':
                  cmd += 'upgrade_v2;'
                else:
                  cmd += 'downgrade_v1;'
                cmd += '/opt/zimbra/bin/zmconvertctl start;'
            </script>
            <process name="'deploy convertd - ' + parameters['host'][0]">
                <location>parameters['host'][0]</location>
                <command mode="'shell'">'%s "%s"'%(su, cmd)</command>
                <workdir>'/opt/zimbra'</workdir>
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
            </process>
            <log>'cmd on %s=%s.'%(parameters['host'][0], cmd)</log>
            <log>'RC=%s,res=%s.'%(RC, STAXResult)</log>
            <return>[RC, STAXResult]</return>
        </sequence>
    </function>

    <function name="configureProxy" scope="local">
        <function-prolog>
            
        </function-prolog>
        <function-map-args>
            <function-required-arg name="parameters">
                param hash
            </function-required-arg>
        </function-map-args>

        <sequence>
            <log level = "'info'">'configureProxy(%s)'%parameters</log>
            <script>
                missing = []
                for p in ['host']:
                  if p in parameters.keys():
                    continue
                  missing.append(p)
            </script>
            <if expr="len(missing) != 0">
                <return>[STAFRC.DoesNotExist, 'plugin configureProxy missing option(s) %s.'%[','].join(missing)]</return>
            </if>
            <script>
                cmd = '/opt/zimbra/bin/zmproxyconfgen;/opt/zimbra/bin/zmproxyctl start;'
            </script>
            <process name="'configure zimbra proxy - ' + parameters['host'][0]">
                <location>parameters['host'][0]</location>
                <command mode="'shell'">'su - zimbra -c "%s"'%cmd</command>
                <workdir>'/opt/zimbra'</workdir>
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
            </process>
            <log>'cmd on %s=%s.'%(parameters['host'][0], cmd)</log>
            <log>'RC=%s,res=%s.'%(RC, STAXResult)</log>
            <return>[RC, STAXResult]</return>
        </sequence>
    </function>
    
    <function name="scheduleBackup" scope="local">
        <function-prolog>
            options: default/delete
        </function-prolog>
        <function-map-args>
            <function-required-arg name="parameters">
                param hash
            </function-required-arg>
        </function-map-args>

        <sequence>
            <log level = "'info'">'scheduleBackup(%s)'%parameters</log>
            <if expr="baseBuildProps['build'].lower().find('foss') != -1">
                <return>[STAFRC.Ok, 'Skipping on FOSS edition']</return>
            </if>
            <script>
                missing = []
                for p in ['host', 'backup']:
                  if p in parameters.keys():
                    continue
                  missing.append(p)
            </script>
            <if expr="len(missing) != 0">
                <return>[STAFRC.DoesNotExist, 'scheduleBackup missing option(s) %s.'%[','].join(missing)]</return>
            </if>
            <script>allowed = ['delete', 'default']</script>
            <if expr="parameters['backup'][0] not in allowed">
                <return>[STAFRC.DoesNotExist, 'scheduleBackup unsupported option %s, allowed options (%s).'%(parameters['backup'][0],[','].join(allowed))]</return>
            </if>
            <script>
                if parameters['backup'][0] == 'delete':
                  opt = '-F'
                else:
                  opt = '-D'
            </script>
            <process name="'schedule backup - ' + parameters['host'][0]">
                <location>parameters['host'][0]</location>
                <command mode="'shell'">'su - zimbra -c "/opt/zimbra/bin/zmschedulebackup %s"'%opt</command>
                <workdir>'/opt/zimbra'</workdir>
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
            </process>
            <log>'cmd on %s=zmschedulebackup %s.'%(parameters['host'][0], opt)</log>
            <log>'RC=%s,res=%s.'%(RC, STAXResult)</log>
            <return>[RC, STAXResult]</return>
        </sequence>
    </function>
    
    <function name="provision" scope="local">
        <function-prolog>
            
        </function-prolog>
        <function-map-args>
            <function-required-arg name="parameters">
                param hash
            </function-required-arg>
        </function-map-args>

        <sequence>
            <log level = "'info'">'provision(%s)'%parameters</log>
            <script>
                missing = []
                for p in ['host', 'command']:
                  if p in parameters.keys():
                    continue
                  missing.append(p)
            </script>
            <if expr="len(missing) != 0">
                <return>[STAFRC.DoesNotExist, 'driver provision missing option(s) %s.'%[','].join(missing)]</return>
            </if>
            <script>
                cmd = 'zmprov'
                if parameters.has_key('useLdap'):
                  cmd += ' ' + parameters['useLdap'][0]
                cmd += ' ' + parameters['command'][0]
                if parameters.has_key('target'):
                  cmd += ' ' + parameters['target'][0]
                if parameters.has_key('arguments'):
                  cmd += ' ' + parameters['arguments'][0]
            </script>
            <process name="'run zmprov - ' + parameters['host'][0]">
                <location>parameters['host'][0]</location>
                <command mode="'shell'">'su - zimbra -c "%s"'%cmd</command>
                <workdir>'/opt/zimbra'</workdir>
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
            </process>
            <log>'cmd on %s=%s.'%(parameters['host'][0], cmd)</log>
            <log>'RC=%s,res=%s.'%(RC, STAXResult)</log>
            <return>[RC, STAXResult]</return>
        </sequence>
    </function>
    
    <function name="certInstall" scope="local">
        <function-prolog>
            
        </function-prolog>
        <function-map-args>
            <function-required-arg name="parameters">
                param hash
            </function-required-arg>
        </function-map-args>

        <sequence>
            <log level = "'info'">'certInstall(%s)'%parameters</log>
            <script>
                missing = []
                for p in ['host']:
                  if p in parameters.keys():
                    continue
                  missing.append(p)
            </script>
            <if expr="len(missing) != 0">
                <return>[STAFRC.DoesNotExist, 'driver certInstall missing option(s) %s.'%[','].join(missing)]</return>
            </if>
            <call function="'getPlatform'">parameters['host'][0]</call>
            <script>
                opts = ''
                if (STAXResult is not None) and (STAXResult.find('MACOSXx86') != -1):
                  opts += '-l'
            </script>     
            <process name="'Get zimbra version -' + parameters['host'][0]">
                <location>parameters['host'][0]</location>
                <command mode="'shell'">'su - zimbra %s -c "/opt/zimbra/bin/zmcontrol -v"'%opts</command>
                <workdir>'/opt/zimbra/bin'</workdir>
                <stdout>'/tmp/version'</stdout>
                <stderr mode="'append'">outputFile[0]</stderr>
                <returnstdout/>
            </process>
            <if expr="RC != STAFRC.Ok">
                <sequence>
                    <script>
                        res = STAFResult
                        if res == None:
                          res = STAXResult[0][1]
                        res = res.replace('\n', '')
                    </script>
                    <return>[RC, res]</return>
                </sequence>
            </if>
            <script>res=STAXResult[0][1].replace('\n', '')</script>
            <script>
                import re
                match=re.search('.*Release\s+([^_]+).*', res)
                if match:
                  release = match.group(1)
            </script>
            <if expr="(match == None)">
                <return>[1, 'Invalid version - %s.'%res]</return>
            </if>
            <log>'zimbra version=%s.'%match.group(1)</log>
            <!--##################################
                1) 5.0.0-5.0.3: copy commercial.csr & commercial.key to /opt/zimbra/ssl/zimbra/commercial
                   5.0.4-up   : copy commercial.csr & commercial_ca.crt to /opt/zimbra/ssl/zimbra/commercial
                2) zmprov ms qaxx.lab.zimbra.com zimbraSSLPrivateKey  "`cat path/to/commercial.key`"
                3) copy all the certs (qa32.liquidsys.com.crt, valicert_class2_root.crt & gd_cross_intermediate.crt & gd_intermediate.crt) into merged.crt
                   zmprov ms qaxx.lab.zimbra.com zimbraSSLCertificate "`cat path/to/merged.crt`"
                4) /opt/zimbra/bin/zmcertmgr deploycrt comm
                    i.e. /opt/zimbra/bin/zmcertmgr deploycrt comm /var/tmp/commcert/qa32.liquidsys.com.crt /var/tmp/commcert/merged.crt
                5) restart the server
                ##################################-->
            <if expr="parameters['host'][0].find('zimbra') == -1">
            <sequence>
            <script>
                commercialCsr = '-----BEGIN CERTIFICATE REQUEST-----\n' +\
                                'MIIC0zCCAbsCAQAwdTELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWEx\n' +\
                                'EjAQBgNVBAcTCVBhbG8gQWx0bzEVMBMGA1UEChMMVk13YXJlLCBJbmMuMQswCQYD\n' +\
                                'VQQLEwJJVDEZMBcGA1UEAxQQKi5lbmcudm13YXJlLmNvbTCCASIwDQYJKoZIhvcN\n' +\
                                'AQEBBQADggEPADCCAQoCggEBALpbZKhGFTIarjIYbqi5SMPGN4F8l5GZL5ws0/XW\n' +\
                                'Kb+tow0GoQk4JRSt0FUBHAvILXPK5bDl8ObzuFdemY9mqgvZdIkZ+gmbDwTRHm/X\n' +\
                                'Ju/eRWdV0nFNJIxQdPjlJ3itmZsw5MshoaThh5e6H0fNaP+LECdd8zQI8NlkXavT\n' +\
                                'McsY7bBjE/YdLPt0kE/K3sl7N1/yex0p69RDbymz+TbkweLtD/UwF9eb6b7t932F\n' +\
                                'kH2dKveYw96C7/PJxZHgsIQioQyjko//YXf0Ng5iOmLiZ345vtjP0kPeCSxFEH67\n' +\
                                'NvLgEF9vpQNXg48h8n7p3LrG4jZ/Fy/wiQepxHLGR+Bjn7MCAwEAAaAZMBcGCSqG\n' +\
                                'SIb3DQEJBzEKEwh0ZXN0MTIzNDANBgkqhkiG9w0BAQUFAAOCAQEAUcB9CSWCu340\n' +\
                                'aQOcYYkVibteDMqdM1gErk8HYJbKZJCUIcBDmyxFlR05yjO5I/NV15WV4jNw+aUP\n' +\
                                'G4wESxq7kXBrOrvONHnz7BiKa6t6Vah2ef3AaoOxl1wOwtAxGp6SgwksUcXJJmro\n' +\
                                'aCHtxmXuQf/DWcQAgMqwrU9q9aeSOhfuBISQFTv9wQwkxYTP1+88ap/p2sc3Ck5d\n' +\
                                'zy5WPYQu4oKf/oybMEJWr4je1WvatzP/qxebL+YfmiIp7Q7W3rom3/rYJdEQv95Q\n' +\
                                'TmjKFjf9s4P3EhsnroKWcf2/ddxd91itpvjkVQ1aa5DTW1kiV02eYLjv9tlYU0F4\n' +\
                                '375Lbv9AHg==\n' +\
                                '-----END CERTIFICATE REQUEST-----'
            </script>
            <script>
                commercialKey = '-----BEGIN RSA PRIVATE KEY-----\n' +\
                                'MIIEpgIBAAKCAQEAultkqEYVMhquMhhuqLlIw8Y3gXyXkZkvnCzT9dYpv62jDQah\n' +\
                                'CTglFK3QVQEcC8gtc8rlsOXw5vO4V16Zj2aqC9l0iRn6CZsPBNEeb9cm795FZ1XS\n' +\
                                'cU0kjFB0+OUneK2ZmzDkyyGhpOGHl7ofR81o/4sQJ13zNAjw2WRdq9MxyxjtsGMT\n' +\
                                '9h0s+3SQT8reyXs3X/J7HSnr1ENvKbP5NuTB4u0P9TAX15vpvu33fYWQfZ0q95jD\n' +\
                                '3oLv88nFkeCwhCKhDKOSj/9hd/Q2DmI6YuJnfjm+2M/SQ94JLEUQfrs28uAQX2+l\n' +\
                                'A1eDjyHyfuncusbiNn8XL/CJB6nEcsZH4GOfswIDAQABAoIBAQCRocBcnEAOIrmE\n' +\
                                'noFDy1/o1msj/si32H1TT9jooc+IYlosYMTR3pVjvp0zAKX5MxsKBUJQZrFG2qlx\n' +\
                                'ZZUdcn5quioOxkUW4pzvB7kAb6OXCh00ruXA8ycfm/R9WR7qeMe0dpYlhAe9QR3k\n' +\
                                'XWf6hbSLFxKtoQbg4CfPy1ZEY8viySfz+azX4QnkkxsYRMkirbZrGmDWyG275fd2\n' +\
                                'LdxUYCuloK4qgpKXIFWVx5t1iaIODs3EC8FI1U3c3L4LrvYdjjNsC90odI0iUr2o\n' +\
                                'hMya7f+uYZPpHal55G6cvK843JxtzUwrH/qGYiJ185PETQK1ogrIiMlJwASpZxEG\n' +\
                                'c46RW/PpAoGBAN2P5dCDMwVTBtJimVNC1j2hUMKo8UUXSpzZnl1bqHcBYsjBCG+y\n' +\
                                'eSwAxiaXBJRzFO+74l3HOsQ5gKagbHvQwRyf7g+esuEznE/iM5sQB/SXMcu3XLLN\n' +\
                                'SGpqxwmXx8m3wHVfB88Rg+iPbBOuC4wpwK7xH7/5UX2L+gD76ETGcIZ3AoGBANdS\n' +\
                                'qVYiuUfGg86dYeyADp/G5TN3lsayef3soH7eYxiU7lMqDd5uP+oBFwedGErQijOh\n' +\
                                'mFS5HI9jPPR0GHqOwpQ2unlZSjGbCygcqhSgKaM4rktmvdVDHreq7WtmZPZDhHIy\n' +\
                                'SQbIlJMgMNNlFMOCdbDGvd5uWnkPFvnlUmxEFvOlAoGBALD9n6dW9238akmsTDFQ\n' +\
                                'BhcLg5lNHheESK1Nxo1riAMxDzmxwkyANP3qzF/NafIwkHwGCgnB+ncAPH5fTuoF\n' +\
                                '1A5K0ACYVOtDsE28NF9dig1grn2/R4TqKjwgekl2fznr2Qmp1XIb2tTvpXV/Jmhc\n' +\
                                'fjkCE8vmnat+I0Of+GbgYsl3AoGBAKC8wVJeq4dsJtrnW8Fruv8FP/ZSsMh1VWH7\n' +\
                                '8bejlcA09VA51Y6VKLsrwyBY4lh/Ipv2ZrvgT/SuNUObIubiiViRHlUWFa/AOOzh\n' +\
                                'sQmiolKJLnt1IAMCjvy26XNCRd4cetOwvBkHRPorjqdQDtcAHZEwW26fXISAgjtc\n' +\
                                'OFI/5g5NAoGBAM47BNoYLroVIoGNoci2WFLx9TBduyIl53v7I5oSomakXDN6ZaO+\n' +\
                                'sjQzMHZF48K2a3pW1wfnNWElpGZ6uJ+3e20i0Y8V1RI9YO5tf1gEJSsdwAMWJtaQ\n' +\
                                'uCBzi3vdf96bFhv/jSEopvDmaRBb0/TkDDoCyyYIPJArSs2tjknS8ouh\n' +\
                                '-----END RSA PRIVATE KEY-----'
            </script>
            </sequence>
            <else>
            <sequence>
            <script>
                commercialCsr = '-----BEGIN CERTIFICATE REQUEST-----\n' +\
                                'MIIDATCCAekCAQAwYDELMAkGA1UEBhMCVVMxDjAMBgNVBAgTBVRleGFzMQ8wDQYD\n' +\
                                'VQQHEwZGcmlzY28xFTATBgNVBAoTDFppbWJyYSwgSW5jLjEZMBcGA1UEAxQQKi5l\n' +\
                                'bmcuemltYnJhLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMca\n' +\
                                'zygYmAhm/7vzP+cYRIXRSqhMv7d9LZoK9CN0VP7YdFKL0oXxRqWDSPgiRWCa+KYt\n' +\
                                'FnPFuqLHMeNt1u3LaxIm1gRkBmac6XBEBmJlHsxWuQjXexSadsp5+Syvche9FhkB\n' +\
                                'uBuaYWDjfbFlepzz+nwVbIstODhsefvO8bGAukWNM99e1RjJ2USLlK9uDZ+NFGdG\n' +\
                                'Thi8HhVYKOtvAePYn359oWUq/UX1bP6pL2LTFzp+yXqImUZL56JNd3wwb7MIc+DR\n' +\
                                'M+g7Wfnk/Kp2yk4aPU+mN7MqR0O7Cv+pj/2uiPf5EbS1TovvdiEOughZL4G+PKqC\n' +\
                                '5Y0DmODimoLwT+2PHoECAwEAAaBcMFoGCSqGSIb3DQEJDjFNMEswCQYDVR0TBAIw\n' +\
                                'ADALBgNVHQ8EBAMCBeAwMQYDVR0RBCowKIIWenFhLTA2MC5lbmcudm13YXJlLmNv\n' +\
                                'bYIOZW5nLnppbWJyYS5jb20wDQYJKoZIhvcNAQEFBQADggEBAE1+nWIKFY8HEISY\n' +\
                                '5DHX/hR8yD2wIyaYX+kRJvacbCoL6ZGYJHWpI5z+kQiAE7wPlDZK/csURpnwVkB7\n' +\
                                'gbyz1JDND3fKjKsZZ6UpDD1D1rIBPb/KAR6vH0MurUS1ulOpgiJMG4Rxs2QvVw6y\n' +\
                                'OkGKuDZNZAJ9A4WKQCVpNsIJC/RtWW3F8HSZxHoQ8p+XSkKl1yh3AqQnDCTjWEVK\n' +\
                                'n2exh+arDSYrHA63kwO/utXVsefuHBc2m6Kw90/GY3lKd69EAHWNFrChg1b3pWc8\n' +\
                                'oy7dk2o1shZxTXZeNGMnEzc7quw+Nv0ixULy9uNd1xqJlbF1OhnDEvvP2gh80hJa\n' +\
                                'G6RMkFs=\n' +\
                                '-----END CERTIFICATE REQUEST-----'
            </script>
            <script>
                commercialKey = '-----BEGIN PRIVATE KEY-----\n' +\
                                'MIIJQwIBADANBgkqhkiG9w0BAQEFAASCCS0wggkpAgEAAoICAQDEYtwSytgc8TXT\n' +\
                                'QSJjmoujghxJkdhcn9K7VRRa/f/M0AiIqNas8wa+ENAAvn9ICVnAFfRtCNko2Yne\n' +\
                                'A9rTuNWnMyh+OZo47D17ayCLmOfdIyQhZc9qiar7Rg1sq+kculuFd87SA6/2LrKN\n' +\
                                'oNA/LxeATnQBi8GMcsHKjbasiM2Ov1SFT40w3Y1msJ1G2YRfDjdeFQ299gbOLHDM\n' +\
                                'rfKTP7kUrWgqUnX7VDu8liwX1nlOeR/FwIzwwEO4yHoZi6HzIPMRXvenYEXwMh4o\n' +\
                                'H3cRkBLGHNpH+ObPahQNv7uyPjYdr8vhBimlG8ZrdFGPmQE1nRWJbj98jS/lh90Q\n' +\
                                '58UMc7GbMM5HktFxWRSf9XyS4PaqYJ1SuPfTD/NIoIs/1BfBm0Pqs0KDao5PCmPh\n' +\
                                'EqYNO8D9Lf/E9rYfwXYFSJCXUEvXndKVHWxxgkoS8DfHy+qwfMupgDWYeDMrNFv9\n' +\
                                '/2bMhnmIG6/ZwgfwspUUV4f7TZ6p0QRkVS7GOalu4DkYZHGfoN7IivGAj+a811yB\n' +\
                                'S7yLjx+jqA3eTk3f5RO6dWoibtlklhY6m90A0YuKxZXYTgwnQLH2m/JOp0OUE3HH\n' +\
                                'Rk+h72fR09JhX/bzkEqvE4eEpJjfIFFTFwgINgGq6v16qX2SCfUIXfKD87ZKIMnc\n' +\
                                'sBB5JLzB0tBIlws6+Z+iDKC5uMs6dwIDAQABAoICAQCVPn/69BaK4DDEi/JjeZZ3\n' +\
                                'OzDeJC0mLvuKDB09DVyxvMNPf+gtZT+Rf9tjRWIbT6faV5T6q8fEyJWCmLFbR1Nv\n' +\
                                'DmzOiF4Qtk//FCmWjSxgHQ2fJ+0aDOdYsCMRnA+7GlDlPGh7p/u4fkKJaVX5PoOA\n' +\
                                'qZ51ck0zvB5UHaBevFRjEDpeWVd2dFi6WqwbpMB5MKeZIyzfWTJQyusqUWNQzhOM\n' +\
                                'iD/qMeKhjqEbL5DwyLhFj706nps9dw/ARPKtqTT5POgcImzY0Uw1PxE18rudKD1s\n' +\
                                'O48TNS/LHtWAoV42FhswMmIhb3qElHgVPz+gfmmx4d/1IkizEeT9bWPuLgTM8rtc\n' +\
                                'XNBuUERy5VmZYhGFkUS5YAlO+hT33CiEVEVdelLPmqPyalqtiEHQOoRmHRGQePJX\n' +\
                                'xoospplqYKwyBH9Zivr2RnQxdShwr10ag1tVAEfXl2EyPjytJwxQIkJ5uHPgAtlH\n' +\
                                'XIJf+Ue08P80r0cMJerUqx7Wpm2s+F7FKx65dmtcJwg57JP+cOLPsu2uw1IU7SAt\n' +\
                                'Fl/C35u/zAf94lZif1wGoB/wRcGhtPOP3/pl9bzeyZV6QemACMnJuIcjev4DPvSa\n' +\
                                'qgul8qjj4BA+3jTelQASqlOqoyIusk9Na67P31hew+MIBDOYEuZoNMj8fexm8N40\n' +\
                                'k/2FKqy/YyzC/FWrtSs48QKCAQEA7Ipis94Bz2wHjv1DDadKurSzmkigXF5SX0QX\n' +\
                                '5RKkLXctDWYYpZw5bt8YQdTlv5q/LdB3oyylYlqwCnpmDQryEBZSO4+QWmSKErWP\n' +\
                                'alT8Hc3Cd8Mk0uqsHPI8J1sijrUcZpe32Pfzv+6FJ9cVCxivedasV2BuQwGUNKuZ\n' +\
                                'byVwxBBR1WEjc/o1PUCnDgJg6GOzLALC0KnpySlBFxSE4Fgql1DqAJPjG8MY4sU7\n' +\
                                'zSz1PPOVD6w2rYkfwWU2l5PWdM3W0D5Ot18faNFuck2GwocpSZzgznBYkv3NLSJp\n' +\
                                'wY6G8zO+pnfM/Ot2k6l4+OWXXk9lpF78OyaeINm7FdXldMXkKQKCAQEA1IrPgqrx\n' +\
                                '3VikrTBY33w+MAdKyk4/Lk2+fJCX1tb3znyBIKAZZcfy7ljpMMCi8OwBw98poT5w\n' +\
                                'R/k+678UJyZ4bFaOPRqzHMELy5iuLslY5x3iwmdx5PC1azaagz3097mDMYAKiQW3\n' +\
                                'lZ7DdUSfR/jPA+2D/Ptg7sG7RnlpKJSrkXzJ4Z6jNFpxAfdzyNk3YyRaawaFbNwz\n' +\
                                'oFHHeEUMyI8VjS7hDHBneM4kFA4cwIL68RwRybA1zo2Ia+4QaCnQ+Un6R99ihzWV\n' +\
                                'kwnsr3Sdc4tnEhDISwEO0qCaXbB8+YLv8rgeXUdX+oQvqPA13zQw9hW+5m9mmmA4\n' +\
                                'XpqKOhEmYPb9nwKCAQEA6JIEDB/Lndr075V6OVF0O3Dyak7gRRGEYiC8ccHLZNyZ\n' +\
                                'kmQA9cxN+AIogonGP4byVCR1jR2XmsXZ8uN3tXk+mayou+EjKI1T6KNVWFIo9VDa\n' +\
                                '1RAtA6gzA970YCnOJ4xRWVnxLMZWhi8KAysJiLiDyALXvq2UnBNQWh0iplKktlHp\n' +\
                                'dCinSCAJ+qi32CFkkPl+MFain7GAqQYD9qJ5J2/oqJCpE1pU4XYI4ObWLpz2nzBM\n' +\
                                'LnW/6Q47B9bxP0XfhUbh4CxzDv7bDh9lPcOWLWvhn3w82R1DKXucIbWFUAdIDpWg\n' +\
                                '7WI7Ta5iDzuBMw/irZrZMC0oSSxmK5yIwyZlDlSISQKCAQB613ez+AUuf2s+RfE3\n' +\
                                'yeFPdQd/AdZ2dqyf5ho8K6ayCze+mYnUT8pSg8TTTqNeR6mFgdfXv/S5RI9fReLp\n' +\
                                '9cwoIaa4HlRjTBf7JlWV6P2fJqDG527meVEBlF+ddxO8kdYHqA9uvoUqzsX9YxoE\n' +\
                                'SQOtK3vbnZaaqBILW2Sx9atrvQoZgsylF5i1IEYlUZY3kO1Jak13a5XTFTEKjC4l\n' +\
                                'RL2aCfw8akMDiXFEvhtUEN/ktup4/YU7yoWMi92jtnd3fZBQNgYGS6wVfej0R5wx\n' +\
                                'CeMah+SbpRLiHbzaZYT12P3B9TRniTKKMhgxthQM22do84yQNtbAZthtpTg682qR\n' +\
                                'JG/VAoIBAGF3z2DkjIl+xCmc0fmRurHTr7dRQYmP3OSumhlZrNj8MNdZuMkbpH6m\n' +\
                                'vQKwiznOLUWE5Ns2AJfAwjm40SZbKVvv6L66Sb+8chIui+6HP+8Mn8HWmkqfoHf5\n' +\
                                'E7AdnxyKXJ8lY6dv5Qr6Tc4ZqhlKfvilVlEYAKaxJ9AYbZkioVJQdxCU8OeklTtG\n' +\
                                '6OLNUxqAGDNf5bON+t6QH8DYMQRnsyrjJ3iDndWU2t7zl1Dm3L5CHAoMszbUDhsP\n' +\
                                'v5E9Wmk0GoBqIQyavgnvksFIOW2DN0G7vkw6by96T8YiJXFsexscmyJl5Dlslyot\n' +\
                                '5SA3yWClquZFnDk6JXXDxFrGK4QWRpI=\n' +\
                                '-----END PRIVATE KEY-----'
            </script>
            </sequence>
            </else>
            </if>
            
            <process name="'Create commercial - ' + parameters['host'][0]">
                <location>parameters['host'][0]</location>
                <command>'/bin/echo'</command>
                <workdir>'/tmp'</workdir>
                <parms>'%s' % commercialCsr</parms>
                <stdout>'/opt/zimbra/ssl/zimbra/commercial/commercial.csr'</stdout>
                <stderr mode="'append'">outputFile[0]</stderr>
                <returnstderr/>
            </process>
            <if expr="RC != STAFRC.Ok">
                <sequence>
                    <script>
                        res = STAFResult
                        if res == None:
                          res = STAXResult[0][1]
                        res = res.replace('\n', '')
                    </script>
                    <return>[RC, res]</return>
                </sequence>
            </if>
            <script>file='commercial.key'</script> 
            <process name="'Create ' + file + ' - ' + parameters['host' ][0]">
                <location>parameters['host'][0]</location>
                <command>'/bin/echo'</command>
                <workdir>'/tmp'</workdir>
                <parms>'%s' % commercialKey</parms>
                <stdout>'/opt/zimbra/ssl/zimbra/commercial/%s'%file</stdout>
                <stderr mode="'append'">outputFile[0]</stderr>
                <returnstderr/>
            </process>
            <if expr="RC != STAFRC.Ok">
                <sequence>
                    <script>
                        res = STAFResult
                        if res == None:
                          res = STAXResult[0][1]
                        res = res.replace('\n', '')
                    </script>
                    <return>[RC, res]</return>
                </sequence>
            </if>
            <process name="'Provision zimbraSSLPrivateKey - ' + parameters['host'][0]">
                <location>parameters['host'][0]</location>
                <command mode="'shell'">'su - zimbra %s -c "/opt/zimbra/bin/zmprov ms %s zimbraSSLPrivateKey  \\\"`cat /opt/zimbra/ssl/zimbra/commercial/%s`\\\""'%(opts, parameters['host'][0], file)</command>
                <workdir>'/opt/zimbra/bin'</workdir>
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
                <returnstdout/>
            </process>
            <if expr="RC != STAFRC.Ok">
                <sequence>
                    <script>
                        res = STAFResult
                        if res == None:
                          res = STAXResult[0][1]
                        res = res.replace('\n', '')
                    </script>
                    <return>[RC, res]</return>
                </sequence>
            </if>
            <if expr="parameters['host'][0].find('zimbra') == -1">
            <sequence>
            <script>
                starLabZimbraComCrt = '-----BEGIN CERTIFICATE-----\n' +\
                                      'MIIGvTCCBaWgAwIBAgIQApMQLrASpeYx9DInTwfRGzANBgkqhkiG9w0BAQUFADBm\n' +\
                                      'MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n' +\
                                      'd3cuZGlnaWNlcnQuY29tMSUwIwYDVQQDExxEaWdpQ2VydCBIaWdoIEFzc3VyYW5j\n' +\
                                      'ZSBDQS0zMB4XDTEyMTAxNzAwMDAwMFoXDTE2MDEwNjEyMDAwMFowdTELMAkGA1UE\n' +\
                                      'BhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExEjAQBgNVBAcTCVBhbG8gQWx0bzEV\n' +\
                                      'MBMGA1UEChMMVk13YXJlLCBJbmMuMQswCQYDVQQLEwJJVDEZMBcGA1UEAwwQKi5l\n' +\
                                      'bmcudm13YXJlLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALpb\n' +\
                                      'ZKhGFTIarjIYbqi5SMPGN4F8l5GZL5ws0/XWKb+tow0GoQk4JRSt0FUBHAvILXPK\n' +\
                                      '5bDl8ObzuFdemY9mqgvZdIkZ+gmbDwTRHm/XJu/eRWdV0nFNJIxQdPjlJ3itmZsw\n' +\
                                      '5MshoaThh5e6H0fNaP+LECdd8zQI8NlkXavTMcsY7bBjE/YdLPt0kE/K3sl7N1/y\n' +\
                                      'ex0p69RDbymz+TbkweLtD/UwF9eb6b7t932FkH2dKveYw96C7/PJxZHgsIQioQyj\n' +\
                                      'ko//YXf0Ng5iOmLiZ345vtjP0kPeCSxFEH67NvLgEF9vpQNXg48h8n7p3LrG4jZ/\n' +\
                                      'Fy/wiQepxHLGR+Bjn7MCAwEAAaOCA1YwggNSMB8GA1UdIwQYMBaAFFDqc4nbKfsQ\n' +\
                                      'j57lASDU3nmZSIP3MB0GA1UdDgQWBBTjOVyGnbFd8P47oRPOPY3TVyN/5TArBgNV\n' +\
                                      'HREEJDAighAqLmVuZy52bXdhcmUuY29tgg5lbmcudm13YXJlLmNvbTAOBgNVHQ8B\n' +\
                                      'Af8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMGEGA1UdHwRa\n' +\
                                      'MFgwKqAooCaGJGh0dHA6Ly9jcmwzLmRpZ2ljZXJ0LmNvbS9jYTMtZzE2LmNybDAq\n' +\
                                      'oCigJoYkaHR0cDovL2NybDQuZGlnaWNlcnQuY29tL2NhMy1nMTYuY3JsMIIBxAYD\n' +\
                                      'VR0gBIIBuzCCAbcwggGzBglghkgBhv1sAQEwggGkMDoGCCsGAQUFBwIBFi5odHRw\n' +\
                                      'Oi8vd3d3LmRpZ2ljZXJ0LmNvbS9zc2wtY3BzLXJlcG9zaXRvcnkuaHRtMIIBZAYI\n' +\
                                      'KwYBBQUHAgIwggFWHoIBUgBBAG4AeQAgAHUAcwBlACAAbwBmACAAdABoAGkAcwAg\n' +\
                                      'AEMAZQByAHQAaQBmAGkAYwBhAHQAZQAgAGMAbwBuAHMAdABpAHQAdQB0AGUAcwAg\n' +\
                                      'AGEAYwBjAGUAcAB0AGEAbgBjAGUAIABvAGYAIAB0AGgAZQAgAEQAaQBnAGkAQwBl\n' +\
                                      'AHIAdAAgAEMAUAAvAEMAUABTACAAYQBuAGQAIAB0AGgAZQAgAFIAZQBsAHkAaQBu\n' +\
                                      'AGcAIABQAGEAcgB0AHkAIABBAGcAcgBlAGUAbQBlAG4AdAAgAHcAaABpAGMAaAAg\n' +\
                                      'AGwAaQBtAGkAdAAgAGwAaQBhAGIAaQBsAGkAdAB5ACAAYQBuAGQAIABhAHIAZQAg\n' +\
                                      'AGkAbgBjAG8AcgBwAG8AcgBhAHQAZQBkACAAaABlAHIAZQBpAG4AIABiAHkAIABy\n' +\
                                      'AGUAZgBlAHIAZQBuAGMAZQAuMHsGCCsGAQUFBwEBBG8wbTAkBggrBgEFBQcwAYYY\n' +\
                                      'aHR0cDovL29jc3AuZGlnaWNlcnQuY29tMEUGCCsGAQUFBzAChjlodHRwOi8vY2Fj\n' +\
                                      'ZXJ0cy5kaWdpY2VydC5jb20vRGlnaUNlcnRIaWdoQXNzdXJhbmNlQ0EtMy5jcnQw\n' +\
                                      'DAYDVR0TAQH/BAIwADANBgkqhkiG9w0BAQUFAAOCAQEAGr/N66c+vtEtFNWz1c30\n' +\
                                      'e4UWi/EwdhWsk6AAevF/TSeRvoUOWgZDOrdk8wr3ciUcQtbHce/bVCF/VHZosctG\n' +\
                                      '8QtywXUExAUAWpAmzCQ/qNXJGd10JGe2ZIPa+rcfzYGcwfmghfWZjBuUN7R9eW0Z\n' +\
                                      'yWIczLrg106CJH6zmif/JJEAK3gyulRgxB6Ex7/GBRNyurCqwyKYUZPwxVWgtuLy\n' +\
                                      'wHNxQFHABH+MLzm/yseutzDNQSfvFJ5jC5TvAclDLlF7cziBOlBbQ/zJBW0xX9Qe\n' +\
                                      'faN2lFwVbpvWP7yPGXc9UYLTaICV7ZXxM31B08/ZskvKQMDXAijoQlG89nUT5Nx/\n' +\
                                      'ZQ==\n' +\
                                      '-----END CERTIFICATE-----\n'
            </script>
            <script>
                digicertCACrt = '-----BEGIN CERTIFICATE-----\n' +\
                                'MIIGWDCCBUCgAwIBAgIQCl8RTQNbF5EX0u/UA4w/OzANBgkqhkiG9w0BAQUFADBs\n' +\
                                'MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n' +\
                                'd3cuZGlnaWNlcnQuY29tMSswKQYDVQQDEyJEaWdpQ2VydCBIaWdoIEFzc3VyYW5j\n' +\
                                'ZSBFViBSb290IENBMB4XDTA4MDQwMjEyMDAwMFoXDTIyMDQwMzAwMDAwMFowZjEL\n' +\
                                'MAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3\n' +\
                                'LmRpZ2ljZXJ0LmNvbTElMCMGA1UEAxMcRGlnaUNlcnQgSGlnaCBBc3N1cmFuY2Ug\n' +\
                                'Q0EtMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL9hCikQH17+NDdR\n' +\
                                'CPge+yLtYb4LDXBMUGMmdRW5QYiXtvCgFbsIYOBC6AUpEIc2iihlqO8xB3RtNpcv\n' +\
                                'KEZmBMcqeSZ6mdWOw21PoF6tvD2Rwll7XjZswFPPAAgyPhBkWBATaccM7pxCUQD5\n' +\
                                'BUTuJM56H+2MEb0SqPMV9Bx6MWkBG6fmXcCabH4JnudSREoQOiPkm7YDr6ictFuf\n' +\
                                '1EutkozOtREqqjcYjbTCuNhcBoz4/yO9NV7UfD5+gw6RlgWYw7If48hl66l7XaAs\n' +\
                                'zPw82W3tzPpLQ4zJ1LilYRyyQLYoEt+5+F/+07LJ7z20Hkt8HEyZNp496+ynaF4d\n' +\
                                '32duXvsCAwEAAaOCAvowggL2MA4GA1UdDwEB/wQEAwIBhjCCAcYGA1UdIASCAb0w\n' +\
                                'ggG5MIIBtQYLYIZIAYb9bAEDAAIwggGkMDoGCCsGAQUFBwIBFi5odHRwOi8vd3d3\n' +\
                                'LmRpZ2ljZXJ0LmNvbS9zc2wtY3BzLXJlcG9zaXRvcnkuaHRtMIIBZAYIKwYBBQUH\n' +\
                                'AgIwggFWHoIBUgBBAG4AeQAgAHUAcwBlACAAbwBmACAAdABoAGkAcwAgAEMAZQBy\n' +\
                                'AHQAaQBmAGkAYwBhAHQAZQAgAGMAbwBuAHMAdABpAHQAdQB0AGUAcwAgAGEAYwBj\n' +\
                                'AGUAcAB0AGEAbgBjAGUAIABvAGYAIAB0AGgAZQAgAEQAaQBnAGkAQwBlAHIAdAAg\n' +\
                                'AEMAUAAvAEMAUABTACAAYQBuAGQAIAB0AGgAZQAgAFIAZQBsAHkAaQBuAGcAIABQ\n' +\
                                'AGEAcgB0AHkAIABBAGcAcgBlAGUAbQBlAG4AdAAgAHcAaABpAGMAaAAgAGwAaQBt\n' +\
                                'AGkAdAAgAGwAaQBhAGIAaQBsAGkAdAB5ACAAYQBuAGQAIABhAHIAZQAgAGkAbgBj\n' +\
                                'AG8AcgBwAG8AcgBhAHQAZQBkACAAaABlAHIAZQBpAG4AIABiAHkAIAByAGUAZgBl\n' +\
                                'AHIAZQBuAGMAZQAuMBIGA1UdEwEB/wQIMAYBAf8CAQAwNAYIKwYBBQUHAQEEKDAm\n' +\
                                'MCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC5kaWdpY2VydC5jb20wgY8GA1UdHwSB\n' +\
                                'hzCBhDBAoD6gPIY6aHR0cDovL2NybDMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0SGln\n' +\
                                'aEFzc3VyYW5jZUVWUm9vdENBLmNybDBAoD6gPIY6aHR0cDovL2NybDQuZGlnaWNl\n' +\
                                'cnQuY29tL0RpZ2lDZXJ0SGlnaEFzc3VyYW5jZUVWUm9vdENBLmNybDAfBgNVHSME\n' +\
                                'GDAWgBSxPsNpA/i/RwHUmCYaCALvY2QrwzAdBgNVHQ4EFgQUUOpzidsp+xCPnuUB\n' +\
                                'INTeeZlIg/cwDQYJKoZIhvcNAQEFBQADggEBAB7ipUiebNtTOA/vphoqrOIDQ+2a\n' +\
                                'vD6OdRvw/S4iWawTwGHi5/rpmc2HCXVUKL9GYNy+USyS8xuRfDEIcOI3ucFbqL2j\n' +\
                                'CwD7GhX9A61YasXHJJlIR0YxHpLvtF9ONMeQvzHB+LGEhtCcAarfilYGzjrpDq6X\n' +\
                                'dF3XcZpCdF/ejUN83ulV7WkAywXgemFhM9EZTfkI7qA5xSU1tyvED7Ld8aW3DiTE\n' +\
                                'JiiNeXf1L/BXunwH1OH8zVowV36GEEfdMR/X/KLCvzB8XSSq6PmuX2p0ws5rs0bY\n' +\
                                'Ib4p1I5eFdZCSucyb6Sxa1GDWL4/bcf72gMhy2oWGU4K8K2Eyl2Us1p292E=\n' +\
                                '-----END CERTIFICATE-----\n' +\
                                '-----BEGIN CERTIFICATE-----\n' +\
                                'MIIFBzCCA++gAwIBAgIETA6m2zANBgkqhkiG9w0BAQUFADCBtDEUMBIGA1UEChML\n' +\
                                'RW50cnVzdC5uZXQxQDA+BgNVBAsUN3d3dy5lbnRydXN0Lm5ldC9DUFNfMjA0OCBp\n' +\
                                'bmNvcnAuIGJ5IHJlZi4gKGxpbWl0cyBsaWFiLikxJTAjBgNVBAsTHChjKSAxOTk5\n' +\
                                'IEVudHJ1c3QubmV0IExpbWl0ZWQxMzAxBgNVBAMTKkVudHJ1c3QubmV0IENlcnRp\n' +\
                                'ZmljYXRpb24gQXV0aG9yaXR5ICgyMDQ4KTAeFw0wNjEwMDExOTQyMjRaFw0xNjEx\n' +\
                                'MDQwMzM4NDRaMGwxCzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMx\n' +\
                                'GTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20xKzApBgNVBAMTIkRpZ2lDZXJ0IEhp\n' +\
                                'Z2ggQXNzdXJhbmNlIEVWIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAw\n' +\
                                'ggEKAoIBAQDGzOVz5vvUu+UtLTKm3+WBP8nNJUm2cSrD1ZQ0Z6IKHLBfaaZAscS3\n' +\
                                'so/QmKSpQVk609yU1jzbdDikSsxNJYL3SqVTEjju80ltcZF+Y7arpl/DpIT4T2JR\n' +\
                                'vvjF7Ns4kuMG5QiRDMQoQVX7y1qJFX5x6DW/TXIJPb46OFBbdzEbjbPHJEWap6xt\n' +\
                                'ABRaBLe6E+tRCphBQSJOZWGHgUFQpnlcid4ZSlfVLuZdHFMsfpjNGgYWpGhz0DQE\n' +\
                                'E1yhcdNafFXbXmThN4cwVgTlEbQpgBLxeTmIogIRfCdmt4i3ePLKCqg4qwpkwr9m\n' +\
                                'XZWEwaElHoddGlALIBLMQbtuC1E4uEvLAgMBAAGjggFmMIIBYjAOBgNVHQ8BAf8E\n' +\
                                'BAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBATAnBgNVHSUEIDAeBggrBgEFBQcDAQYI\n' +\
                                'KwYBBQUHAwIGCCsGAQUFBwMEMDMGCCsGAQUFBwEBBCcwJTAjBggrBgEFBQcwAYYX\n' +\
                                'aHR0cDovL29jc3AuZW50cnVzdC5uZXQwMgYDVR0fBCswKTAnoCWgI4YhaHR0cDov\n' +\
                                'L2NybC5lbnRydXN0Lm5ldC8yMDQ4Y2EuY3JsME8GA1UdIARIMEYwRAYEVR0gADA8\n' +\
                                'MDoGCCsGAQUFBwIBFi5odHRwOi8vd3d3LmRpZ2ljZXJ0LmNvbS9zc2wtY3BzLXJl\n' +\
                                'cG9zaXRvcnkuaHRtMB0GA1UdDgQWBBSxPsNpA/i/RwHUmCYaCALvY2QrwzAfBgNV\n' +\
                                'HSMEGDAWgBRV5IHREYC+2Im5CKMx+aEkCRa5cDAZBgkqhkiG9n0HQQAEDDAKGwRW\n' +\
                                'OC4xAwIAgTANBgkqhkiG9w0BAQUFAAOCAQEAWeGUFInGcjzna3VLJXotPqPbrDxy\n' +\
                                'T5swsKJe1mJdjzZr590jWcGALKDtfhGgyaO79pa4NMn+xtdYtLsnf+VrIwRoYUsW\n' +\
                                'V9/hfsDFNo8MBN7vd2hog218BftF3c4WVpE50liRUZWHnk20CtcFY4NDJt4Iphl3\n' +\
                                'nf5Zol/bMjNKZRDER++6VwcfTJ+vaGXvZ22a3h5eToeF7p0Nez3SA6ndtwUEnpUN\n' +\
                                'wbIR/Vp3xB+Yny6g0Ml80zRi9S+WN0hItCH7L61TZTTCe0p8/JBJn/P3NwieQQCy\n' +\
                                'YxtLufbBfVlmq9HzijAFGHpBR6vHZxQ6fGCxCE7QzsfhraZN7q4yrKzGWg==\n' +\
                                '-----END CERTIFICATE-----\n'
            </script>
            <script>
                trustedRootCrt = '-----BEGIN CERTIFICATE-----\n' +\
                                 'MIIEKjCCAxKgAwIBAgIEOGPe+DANBgkqhkiG9w0BAQUFADCBtDEUMBIGA1UEChML\n' +\
                                 'RW50cnVzdC5uZXQxQDA+BgNVBAsUN3d3dy5lbnRydXN0Lm5ldC9DUFNfMjA0OCBp\n' +\
                                 'bmNvcnAuIGJ5IHJlZi4gKGxpbWl0cyBsaWFiLikxJTAjBgNVBAsTHChjKSAxOTk5\n' +\
                                 'IEVudHJ1c3QubmV0IExpbWl0ZWQxMzAxBgNVBAMTKkVudHJ1c3QubmV0IENlcnRp\n' +\
                                 'ZmljYXRpb24gQXV0aG9yaXR5ICgyMDQ4KTAeFw05OTEyMjQxNzUwNTFaFw0yOTA3\n' +\
                                 'MjQxNDE1MTJaMIG0MRQwEgYDVQQKEwtFbnRydXN0Lm5ldDFAMD4GA1UECxQ3d3d3\n' +\
                                 'LmVudHJ1c3QubmV0L0NQU18yMDQ4IGluY29ycC4gYnkgcmVmLiAobGltaXRzIGxp\n' +\
                                 'YWIuKTElMCMGA1UECxMcKGMpIDE5OTkgRW50cnVzdC5uZXQgTGltaXRlZDEzMDEG\n' +\
                                 'A1UEAxMqRW50cnVzdC5uZXQgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgKDIwNDgp\n' +\
                                 'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArU1LqRKGsuqjIAcVFmQq\n' +\
                                 'K0vRvwtKTY7tgHalZ7d4QMBzQshowNtTK91euHaYNZOLGp18EzoOH1u3Hs/lJBQe\n' +\
                                 'sYGpjX24zGtLA/ECDNyrpUAkAH90lKGdCCmziAv1h3edVc3kw37XamSrhRSGlVuX\n' +\
                                 'MlBvPci6Zgzj/L24ScF2iUkZ/cCovYmjZy/Gn7xxGWC4LeksyZB2ZnuU4q941mVT\n' +\
                                 'XTzWnLLPKQP5L6RQstRIzgUyVYr9smRMDuSYB3Xbf9+5CFVghTAp+XtIpGmG4zU/\n' +\
                                 'HoZdenoVve8AjhUiVBcAkCaTvA5JaJG/+EfTnZVCwQ5N328mz8MYIWJmQ3DW1cAH\n' +\
                                 '4QIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNV\n' +\
                                 'HQ4EFgQUVeSB0RGAvtiJuQijMfmhJAkWuXAwDQYJKoZIhvcNAQEFBQADggEBADub\n' +\
                                 'j1abMOdTmXx6eadNl9cZlZD7Bh/KM3xGY4+WZiT6QBshJ8rmcnPyT/4xmf3IDExo\n' +\
                                 'U8aAghOY+rat2l098c5u9hURlIIM7j+VrxGrD9cv3h8Dj1csHsm7mhpElesYT6Yf\n' +\
                                 'zX1XEC+bBAlahLVu2B064dae0Wx5XnkcFMXj0EyTO2U87d89vqbllRrDtRnDvV5b\n' +\
                                 'u/8j72gZyxKTJ1wDLW8w0B62GqzeWvfRqqgnpv55gcR5mTNXuhKwqeBCbJPKVt7+\n' +\
                                 'bYQLCIt+jerXmCHG8+c8eS9enNFMFY3h7CI3zJpDC5fcgJCNs2ebb0gIFVbPv/Er\n' +\
                                 'fF6adulZkMV8gzURZVE=\n' +\
                                 '-----END CERTIFICATE-----\n'
            </script>
            

            </sequence>
            <else>
            <sequence>
            <script>
                starLabZimbraComCrt = '-----BEGIN CERTIFICATE-----\n' +\
                                      'MIIHhzCCBm+gAwIBAgIQDEWcS80Lw4goPMmdir8hGTANBgkqhkiG9w0BAQUFADBI\n' +\
                                      'MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMSIwIAYDVQQDExlE\n' +\
                                      'aWdpQ2VydCBTZWN1cmUgU2VydmVyIENBMB4XDTEzMTIxMTAwMDAwMFoXDTE2MTIx\n' +\
                                      'NTEyMDAwMFowYDELMAkGA1UEBhMCVVMxDjAMBgNVBAgTBVRleGFzMQ8wDQYDVQQH\n' +\
                                      'EwZGcmlzY28xFTATBgNVBAoTDFppbWJyYSwgSW5jLjEZMBcGA1UEAwwQKi5lbmcu\n' +\
                                      'emltYnJhLmNvbTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMRi3BLK\n' +\
                                      '2BzxNdNBImOai6OCHEmR2Fyf0rtVFFr9/8zQCIio1qzzBr4Q0AC+f0gJWcAV9G0I\n' +\
                                      '2SjZid4D2tO41aczKH45mjjsPXtrIIuY590jJCFlz2qJqvtGDWyr6Ry6W4V3ztID\n' +\
                                      'r/Yuso2g0D8vF4BOdAGLwYxywcqNtqyIzY6/VIVPjTDdjWawnUbZhF8ON14VDb32\n' +\
                                      'Bs4scMyt8pM/uRStaCpSdftUO7yWLBfWeU55H8XAjPDAQ7jIehmLofMg8xFe96dg\n' +\
                                      'RfAyHigfdxGQEsYc2kf45s9qFA2/u7I+Nh2vy+EGKaUbxmt0UY+ZATWdFYluP3yN\n' +\
                                      'L+WH3RDnxQxzsZswzkeS0XFZFJ/1fJLg9qpgnVK499MP80igiz/UF8GbQ+qzQoNq\n' +\
                                      'jk8KY+ESpg07wP0t/8T2th/BdgVIkJdQS9ed0pUdbHGCShLwN8fL6rB8y6mANZh4\n' +\
                                      'Mys0W/3/ZsyGeYgbr9nCB/CylRRXh/tNnqnRBGRVLsY5qW7gORhkcZ+g3siK8YCP\n' +\
                                      '5rzXXIFLvIuPH6OoDd5OTd/lE7p1aiJu2WSWFjqb3QDRi4rFldhODCdAsfab8k6n\n' +\
                                      'Q5QTccdGT6HvZ9HT0mFf9vOQSq8Th4SkmN8gUVMXCAg2Aarq/XqpfZIJ9Qhd8oPz\n' +\
                                      'tkogydywEHkkvMHS0EiXCzr5n6IMoLm4yzp3AgMBAAGjggNTMIIDTzAfBgNVHSME\n' +\
                                      'GDAWgBSQcds363PI79zVHhK2NLorWqCmkjAdBgNVHQ4EFgQUhTz1RNb+rKjxx+XR\n' +\
                                      'i8NlMr5ABEgwKwYDVR0RBCQwIoIQKi5lbmcuemltYnJhLmNvbYIOZW5nLnppbWJy\n' +\
                                      'YS5jb20wDgYDVR0PAQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEF\n' +\
                                      'BQcDAjBhBgNVHR8EWjBYMCqgKKAmhiRodHRwOi8vY3JsMy5kaWdpY2VydC5jb20v\n' +\
                                      'c3NjYS1nNS5jcmwwKqAooCaGJGh0dHA6Ly9jcmw0LmRpZ2ljZXJ0LmNvbS9zc2Nh\n' +\
                                      'LWc1LmNybDCCAcQGA1UdIASCAbswggG3MIIBswYJYIZIAYb9bAEBMIIBpDA6Bggr\n' +\
                                      'BgEFBQcCARYuaHR0cDovL3d3dy5kaWdpY2VydC5jb20vc3NsLWNwcy1yZXBvc2l0\n' +\
                                      'b3J5Lmh0bTCCAWQGCCsGAQUFBwICMIIBVh6CAVIAQQBuAHkAIAB1AHMAZQAgAG8A\n' +\
                                      'ZgAgAHQAaABpAHMAIABDAGUAcgB0AGkAZgBpAGMAYQB0AGUAIABjAG8AbgBzAHQA\n' +\
                                      'aQB0AHUAdABlAHMAIABhAGMAYwBlAHAAdABhAG4AYwBlACAAbwBmACAAdABoAGUA\n' +\
                                      'IABEAGkAZwBpAEMAZQByAHQAIABDAFAALwBDAFAAUwAgAGEAbgBkACAAdABoAGUA\n' +\
                                      'IABSAGUAbAB5AGkAbgBnACAAUABhAHIAdAB5ACAAQQBnAHIAZQBlAG0AZQBuAHQA\n' +\
                                      'IAB3AGgAaQBjAGgAIABsAGkAbQBpAHQAIABsAGkAYQBiAGkAbABpAHQAeQAgAGEA\n' +\
                                      'bgBkACAAYQByAGUAIABpAG4AYwBvAHIAcABvAHIAYQB0AGUAZAAgAGgAZQByAGUA\n' +\
                                      'aQBuACAAYgB5ACAAcgBlAGYAZQByAGUAbgBjAGUALjB4BggrBgEFBQcBAQRsMGow\n' +\
                                      'JAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmRpZ2ljZXJ0LmNvbTBCBggrBgEFBQcw\n' +\
                                      'AoY2aHR0cDovL2NhY2VydHMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0U2VjdXJlU2Vy\n' +\
                                      'dmVyQ0EuY3J0MAwGA1UdEwEB/wQCMAAwDQYJKoZIhvcNAQEFBQADggEBALeLsKEo\n' +\
                                      'AuVw2LX5hPXkzB3loEzy01gv0OpHJ+3oKPZ2+yvI805cbBZ9oR4+HA1bEfRafNjD\n' +\
                                      'zg90SpnSZ/wtTmaEcFK+SNigYwMV04NYIFwbWXA06Avu+WR1h0e9j92tZBkCp4Bi\n' +\
                                      'sSnnBZw5OV7Tfuui2TVWiTJkn2U/9UHCWWQkBVLoZNJZCn/4JCiZcZL4P8t4MJIy\n' +\
                                      'fMdnPIuoOi7y5wpWbncci3RkoX9WYVl+9HWKaofMruw8hSnzqUbZtp7o8xapsFYg\n' +\
                                      '7p2jkeYH4cXybrhcaZWiIW7A/F3d1nzb0KvHqUZ9/z5lL3ix+GUD7QNMgAV5QOSv\n' +\
                                      'HubkewXdOR0wW1s=\n' +\
                                      '-----END CERTIFICATE-----\n'
            </script>
            <script>
                digicertCACrt = '-----BEGIN CERTIFICATE-----\n' +\
                                'MIIEjzCCA3egAwIBAgIQBp4dt3/PHfupevXlyaJANzANBgkqhkiG9w0BAQUFADBh\n' +\
                                'MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n' +\
                                'd3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD\n' +\
                                'QTAeFw0xMzAzMDgxMjAwMDBaFw0yMzAzMDgxMjAwMDBaMEgxCzAJBgNVBAYTAlVT\n' +\
                                'MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxIjAgBgNVBAMTGURpZ2lDZXJ0IFNlY3Vy\n' +\
                                'ZSBTZXJ2ZXIgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC7V+Qh\n' +\
                                'qdWbYDd+jqFhf4HiGsJ1ZNmRUAvkNkQkbjDSm3on+sJqrmpwCTi5IArIZRBKiKwx\n' +\
                                '8tyS8mOhXYBjWYCSIxzm73ZKUDXJ2HE4ue3w5kKu0zgmeTD5IpTG26Y/QXiQ2N5c\n' +\
                                'fml9+JAVOtChoL76srIZodgr0c6/a91Jq6OS/rWryME+7gEA2KlEuEJziMNh9atK\n' +\
                                'gygK0tRJ+mqxzd9XLJTl4sqDX7e6YlwvaKXwwLn9K9HpH9gaYhW9/z2m98vv5ttl\n' +\
                                'LyU47PvmIGZYljQZ0hXOIdMkzNkUb9j+Vcfnb7YPGoxJvinyulqagSY3JG/XSBJs\n' +\
                                'Lln1nBi72fZo4t9FAgMBAAGjggFaMIIBVjASBgNVHRMBAf8ECDAGAQH/AgEAMA4G\n' +\
                                'A1UdDwEB/wQEAwIBhjA0BggrBgEFBQcBAQQoMCYwJAYIKwYBBQUHMAGGGGh0dHA6\n' +\
                                'Ly9vY3NwLmRpZ2ljZXJ0LmNvbTB7BgNVHR8EdDByMDegNaAzhjFodHRwOi8vY3Js\n' +\
                                'My5kaWdpY2VydC5jb20vRGlnaUNlcnRHbG9iYWxSb290Q0EuY3JsMDegNaAzhjFo\n' +\
                                'dHRwOi8vY3JsNC5kaWdpY2VydC5jb20vRGlnaUNlcnRHbG9iYWxSb290Q0EuY3Js\n' +\
                                'MD0GA1UdIAQ2MDQwMgYEVR0gADAqMCgGCCsGAQUFBwIBFhxodHRwczovL3d3dy5k\n' +\
                                'aWdpY2VydC5jb20vQ1BTMB0GA1UdDgQWBBSQcds363PI79zVHhK2NLorWqCmkjAf\n' +\
                                'BgNVHSMEGDAWgBQD3lA1VtFMu2bwo+IbG8OXsj3RVTANBgkqhkiG9w0BAQUFAAOC\n' +\
                                'AQEAMM7RlVEArgYLoQ4CwBestn+PIPZAdXQczHixpE/q9NDEnaLegQcmH0CIUfAf\n' +\
                                'z7dMQJnQ9DxxmHOIlywZ126Ej6QfnFog41FcsMWemWpPyGn3EP9OrRnZyVizM64M\n' +\
                                '2ZYpnnGycGOjtpkWQh1l8/egHn3F1GUUsmKE1GxcCAzYbJMrtHZZitF//wPYwl24\n' +\
                                'LyLWOPD2nGt9RuuZdPfrSg6ppgTre87wXGuYMVqYQOtpxAX0IKjKCDplbDgV9Vws\n' +\
                                'slXkLGtB8L5cRspKKaBIXiDSRf8F3jSvcEuBOeLKB1d8tjHcISnivpcOd5AUUUDh\n' +\
                                'v+PMGxmcJcqnBrJT3yOyzxIZow==\n' +\
                                '-----END CERTIFICATE-----\n'
            </script>
            <script>
                trustedRootCrt = '-----BEGIN CERTIFICATE-----\n' +\
                                 'MIIDrzCCApegAwIBAgIQCDvgVpBCRrGhdWrJWZHHSjANBgkqhkiG9w0BAQUFADBh\n' +\
                                 'MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n' +\
                                 'd3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD\n' +\
                                 'QTAeFw0wNjExMTAwMDAwMDBaFw0zMTExMTAwMDAwMDBaMGExCzAJBgNVBAYTAlVT\n' +\
                                 'MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j\n' +\
                                 'b20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290IENBMIIBIjANBgkqhkiG\n' +\
                                 '9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4jvhEXLeqKTTo1eqUKKPC3eQyaKl7hLOllsB\n' +\
                                 'CSDMAZOnTjC3U/dDxGkAV53ijSLdhwZAAIEJzs4bg7/fzTtxRuLWZscFs3YnFo97\n' +\
                                 'nh6Vfe63SKMI2tavegw5BmV/Sl0fvBf4q77uKNd0f3p4mVmFaG5cIzJLv07A6Fpt\n' +\
                                 '43C/dxC//AH2hdmoRBBYMql1GNXRor5H4idq9Joz+EkIYIvUX7Q6hL+hqkpMfT7P\n' +\
                                 'T19sdl6gSzeRntwi5m3OFBqOasv+zbMUZBfHWymeMr/y7vrTC0LUq7dBMtoM1O/4\n' +\
                                 'gdW7jVg/tRvoSSiicNoxBN33shbyTApOB6jtSj1etX+jkMOvJwIDAQABo2MwYTAO\n' +\
                                 'BgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUA95QNVbR\n' +\
                                 'TLtm8KPiGxvDl7I90VUwHwYDVR0jBBgwFoAUA95QNVbRTLtm8KPiGxvDl7I90VUw\n' +\
                                 'DQYJKoZIhvcNAQEFBQADggEBAMucN6pIExIK+t1EnE9SsPTfrgT1eXkIoyQY/Esr\n' +\
                                 'hMAtudXH/vTBH1jLuG2cenTnmCmrEbXjcKChzUyImZOMkXDiqw8cvpOp/2PV5Adg\n' +\
                                 '06O/nVsJ8dWO41P0jmP6P6fbtGbfYmbW0W5BjfIttep3Sp+dWOIrWcBAI+0tKIJF\n' +\
                                 'PnlUkiaY4IBIqDfv8NZ5YBberOgOzW6sRBc4L0na4UU+Krk2U886UAb3LujEV0ls\n' +\
                                 'YSEY1QSteDwsOoBrp+uvFRTp2InBuThs4pFsiv9kuXclVzDAGySj4dzp30d8tbQk\n' +\
                                 'CAUw7C29C79Fv1C5qfPrmAESrciIxpg0X40KPMbp1ZWVbd4=\n' +\
                                 '-----END CERTIFICATE-----\n'
            </script>
            </sequence>
            </else>
            </if>
            
            <script>qaFile='commercial.crt'</script> 
            <process name="'Create ' + qaFile + ' - ' + parameters['host' ][0]">
                <location>parameters['host'][0]</location>
                <command>'/bin/echo'</command>
                <workdir>'/tmp'</workdir>
                <parms>starLabZimbraComCrt</parms>
                <stdout>'/tmp/%s'%qaFile</stdout>
                <stderr mode="'append'">outputFile[0]</stderr>
                <returnstderr/>
            </process>
            <if expr="RC != STAFRC.Ok">
                <sequence>
                    <script>
                        res = STAFResult
                        if res == None:
                          res = STAXResult[0][1]
                        res = res.replace('\n', '')
                    </script>
                    <return>[RC, res]</return>
                </sequence>
            </if>
            <script>mergedFile='commercial_ca.crt'</script> 
            <process name="'Create ' + file + ' - ' + parameters['host' ][0]">
                <location>parameters['host'][0]</location>
                <command>'/bin/echo'</command>
                <workdir>'/tmp'</workdir>
                <parms>starLabZimbraComCrt + trustedRootCrt + digicertCACrt</parms>
                <stdout>'/tmp/%s'%mergedFile</stdout>
                <stderr mode="'append'">outputFile[0]</stderr>
                <returnstderr/>
            </process>
            <if expr="RC != STAFRC.Ok">
                <sequence>
                    <script>
                        res = STAFResult
                        if res == None:
                          res = STAXResult[0][1]
                        res = res.replace('\n', '')
                    </script>
                    <return>[RC, res]</return>
                </sequence>
            </if>
            <process name="'Fixperms - ' + parameters['host'][0]">
                <location>parameters['host'][0]</location>
                <command mode="'shell'">'/opt/zimbra/libexec/zmfixperms'</command>
                <workdir>'/opt/zimbra/bin'</workdir>
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
            </process>
            <process name="'Certificate install - ' + parameters['host'][0]">
                <location>parameters['host'][0]</location>
                <command mode="'shell'">'/opt/zimbra/bin/zmcertmgr deploycrt comm /tmp/%s /tmp/%s'%(qaFile, mergedFile)</command>
                <workdir>'/opt/zimbra/bin'</workdir>
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
                <returnstderr/>
            </process>
            <if expr="RC != STAFRC.Ok">
                <sequence>
                    <script>
                        res = STAFResult
                        if res == None:
                          res = STAXResult[0][1]
                        res = res.replace('\n', '')
                    </script>
                    <return>[RC, res]</return>
                </sequence>
            </if>
            <if expr="re.search('6\.0\.(\d{2}|[7-9])', release) == None">
                <sequence>
                    <process name="'Add cacerts - ' + parameters['host'][0]">
                        <location>parameters['host'][0]</location>
                        <command mode="'shell'">'/opt/zimbra/bin/zmcertmgr addcacert /tmp/%s'%(mergedFile)</command>
                        <workdir>'/opt/zimbra/bin'</workdir>
                        <stdout mode="'append'">outputFile[0]</stdout>
                        <stderr mode="'stdout'"/>
                        <returnstderr/>
                    </process>
                    <if expr="RC != STAFRC.Ok">
                        <sequence>
                            <script>
                                res = STAFResult
                                if res == None:
                                  res = STAXResult[0][1]
                                res = res.replace('\n', '')
                            </script>
                            <return>[RC, res]</return>
                        </sequence>
                    </if>
                </sequence>
            </if>
            <process name="'Server restart - ' + parameters['host'][0]">
                <location>parameters['host'][0]</location>
                <command mode="'shell'">'su - zimbra %s -c "/opt/zimbra/bin/zmcontrol stop; /opt/zimbra/bin/zmcontrol start"'%opts</command>
                <workdir>'/opt/zimbra/bin'</workdir>
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
                <returnstderr/>
            </process>
            <if expr="RC != STAFRC.Ok">
                <sequence>
                    <script>
                        res = STAFResult
                        if res == None:
                          res = STAXResult[0][1]
                        res = res.replace('\n', '')
                    </script>
                    <return>[RC, res]</return>
                </sequence>
            </if>
            <return>[STAFRC.Ok, 'Completed']</return>
        </sequence>
    </function>
   
    <function name="getRunningTime" scope="local">
        <function-prolog>
            This function is used to sum up all running times fuond in the install log
        </function-prolog>
        <function-map-args>
            <function-required-arg name="machine">
                machine
            </function-required-arg>
            <function-required-arg name="build">
                build id
            </function-required-arg>
            <function-optional-arg name="outputFile" default="'/tmp/install.out'">
                Stdout file
            </function-optional-arg>
        </function-map-args>
        <sequence>
            <script>rex="^real[[:space:]][[:digit:]]\\\+"</script>
            <process name="'Scan for run time - ' + machine">
                <location>machine</location>
                <command>'grep'</command>
                <workdir>'/var/tmp'</workdir>
                <parms>' -i "%s" /tmp/install.out.%s' % (rex, build)</parms>
                <stdout>outputFile</stdout>
                <stderr mode="'stdout'"/>
                <returnstdout/>
            </process>   
            <if expr="RC == STAFRC.Ok and STAXResult[0][1] != ''">
                <sequence>
                    <script>
                        import re
                        lines = STAXResult[0][1].splitlines()
                        res = "running time - " + machine + ":"
                        secs = 0
                        for line in lines:
                           secs += float(re.split('\s+', line)[1])
                        secs = int(secs + .5)
                        hours = secs / 3600
                        if hours != 0:
                           secs %= 3600
                           res += "    " + str(hours) + " hour(s)"
                        minutes = secs /60
                        if minutes != 0:
                           secs %= 60
                           res += "    " + str(minutes) + " minute(s)"
                        if secs != 0:
                           res += "    " + str(secs) + " second(s)"
                    </script>
                    <return>[STAFRC.Ok, res]</return>
                </sequence>
                <else>
                    <return>[STAFRC.DoesNotExist, "running time - " + machine + ": UNKNOWN"]</return>
                </else>
            </if>
        </sequence>
    </function>
  
    <function name="getBugReport" scope="local">
        <function-prolog>
            This function returns genesis bug report
        </function-prolog>
        <function-map-args>
            <function-required-arg name="uri">
                Report location
            </function-required-arg>
            <function-required-arg name="machine">
                hostname
            </function-required-arg>
        </function-map-args>
        <sequence>
            <script>
                import re
                bugReport = re.sub("^.*testlogs", '/opt/qa/testlogs', uri) + "BugReport.txt"
            </script>
            <stafcmd>
                <location>machine</location>
		        <service>'fs'</service>
		        <request>'GET FILE %s'% (bugReport)</request> 
		    </stafcmd>
            <return>[RC, STAFResult]</return>
        </sequence>
    </function>
    
    <function name="systemCommand" scope="local">
        <function-prolog>
            
        </function-prolog>
        <function-map-args>
            <function-required-arg name="parameters">
                param hash
            </function-required-arg>
        </function-map-args>

        <sequence>
            <log level = "'info'">'systemCommand(%s)'%parameters</log>
            <script>
                missing = []
                for p in ['host', 'user', 'cmd', 'parms']:
                  if p in parameters.keys():
                    continue
                  missing.append(p)
            </script>
            <if expr="len(missing) != 0">
                <return>[STAFRC.DoesNotExist, 'plugin systemCommand missing option(s) %s.'%[','].join(missing)]</return>
            </if>
            <call function="'getPlatform'">parameters['host'][0]</call>
            <script>
                opt = ''
                su = ''
                if (STAXResult is not None) and (STAXResult.find('MACOSXx86') != -1):
                  opt = ' -l'
                if parameters['user'][0] != 'root':
                  su = 'su - ' + parameters['user'][0] + opt + ' -c '
                cmd = parameters['cmd'][0] + ' ' + parameters['parms'][0]
            </script>
            <process name="'run system command ' + cmd + ' - ' + parameters['host'][0]">
                <location>parameters['host'][0]</location>
                <command mode="'shell'">'%s "%s"'%(su, cmd)</command>
                <workdir>'/opt/zimbra'</workdir>
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
            </process>
            <log>'cmd on %s=%s.'%(parameters['host'][0], cmd)</log>
            <log>'RC=%s,res=%s.'%(RC, STAXResult)</log>
            <return>[RC, STAXResult]</return>
        </sequence>
    </function>
    
    <function name="runZmCommand" scope="local">
        <function-prolog>
            
        </function-prolog>
        <function-map-args>
            <function-required-arg name="parameters">
                param hash
            </function-required-arg>
        </function-map-args>

        <sequence>
            <log level = "'info'">'runZmCommand(%s)'%parameters</log>
            <call function="'getPlatform'">parameters['host'][0]</call>
            <script>
                opt = ''
                if (STAXResult is not None) and (STAXResult.find('MACOSXx86') != -1):
                  opt = ' -l'
            </script>
            <script>
                su = 'su - zimbra' + opt + ' -c '
                missing = []
                for p in ['host', 'cmd', 'parms']:
                  if p in parameters.keys():
                    continue
                  missing.append(p)
            </script>
            <if expr="len(missing) != 0">
                <return>[STAFRC.DoesNotExist, 'plugin runZmCommand missing option(s) %s.'%[','].join(missing)]</return>
            </if>
            <script>
                cmd = parameters['cmd'][0] + ' ' + parameters['parms'][0]
            </script>
            <process name="'run zimbra command ' + cmd + ' - ' + parameters['host'][0]">
                <location>parameters['host'][0]</location>
                <command mode="'shell'">'%s "%s"'%(su, cmd)</command>
                <workdir>'/opt/zimbra'</workdir>
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
            </process>
            <log>'cmd on %s=%s.'%(parameters['host'][0], cmd)</log>
            <log>'RC=%s,res=%s.'%(RC, STAXResult)</log>
            <return>[RC, STAXResult]</return>
        </sequence>
    </function>

    <function name="runPlugins" scope="local">
        <function-prolog>
            
        </function-prolog>
        <function-list-args>
            <function-required-arg name="plan">
                Test -plan
            </function-required-arg>
            <function-required-arg name="plug">
                Runs only the plugins for this plug
                one of preInstall, preZmsetup, postInstall, preUpgrade, preZmupgrade, postUpgrade
            </function-required-arg>
        </function-list-args>

        <sequence>
            <signalhandler signal="'STAXFunctionDoesNotExist'">
                <sequence>
                    <log message="1" level="'Error'">
                        'STAXFunctionDoesNotExist signal raised.%s' % \
                        (STAXFunctionDoesNotExistMsg)
                </log>
                    <throw exception="'STAXFunctionDoesNotExist'"/>
                </sequence>
            </signalhandler>
            <log level = "'info'">'runPlugins(%s, %s)'%(plan, plug)</log>
            <if expr="plug not in ['preInstall', 'preZmsetup', 'postInstall', 'preUpgrade', 'preZmupgrade', 'postUpgrade']">
                <sequence>
                    <log>'runPlugins - Invalid plug %s'%plug</log>
                    <return>[STAFRC.DoesNotExist, 'No such plug - %s'%plug]</return>
                </sequence>
            </if>
            <script>
                try:
                   plugins
                except NameError:
                   plugins = None
            </script>
            <if expr="plugins is None">
                <sequence>
                    <call function="'parseXML'">plan</call>
                    <script>
                        document = STAXResult
                        plugins = []
                        node = document.getElementsByTagName("plugins")
                        if node.getLength() == 1:
                          allPlugins = node.item(0).getElementsByTagName("plugin")
                          for i in range(allPlugins.getLength()):
                            crt = allPlugins.item(i)
                            if crt.getAttributes().getNamedItem('name') == None:
                              continue #noname plugin, skipping
                            name = crt.getAttributes().getNamedItem('name').getNodeValue()
                            args = {}
                            options = crt.getElementsByTagName("option")
                            for i in range(options.getLength()):
                              option = options.item(i)
                              val = option.getFirstChild()
                              key = option.getAttributes().getNamedItem('name').getNodeValue()
                              if val != None:
                                val = option.getFirstChild().getNodeValue().strip().replace('\n', '').split(',')
                              else:
                                val = []
                              args[key] = args.get(key, []) + val
                              #args[option.getAttributes().getNamedItem('name').getNodeValue()] = val
                            plugins.append([name, args])
                    </script>
                </sequence>
            </if>
            <log>'plugins=%s.'%plugins</log>
            
            <if expr="len(plugins) == 0">
                <sequence>
                    <log>'runPlugins - No %s plugins defined'%plug</log>
                    <return>[STAFRC.Ok, 'No %s plugins defined'%plug]</return>
                </sequence>
            </if>
            <iterate var="i" in="range(len(plugins))">
                <sequence>
                    <script>
                        plugin = plugins[i][0]
                        args = plugins[i][1]
                    </script>
                    <if expr="args.has_key('plugs') and plug in args['plugs']">
                        <try>
                            <sequence>
                                <call function="plugin">{'parameters': args}</call>
                            </sequence>
                            <catch exception="'STAXFunctionDoesNotExist'">
                                <sequence>
                                    <log>'Plugin not supported - %s'%plugin</log>
                                    <return>[STAFRC.Ok, 'Plugin not supported - %s'%plugin]</return>
                                </sequence>
                            </catch>
                        </try>
                    </if>
                </sequence>
            </iterate>
            <return>[STAFRC.Ok, '%s plugins execution completed'%plug]</return>
        </sequence>
    </function>
    
	<function name="download" scope="local">
        <function-prolog>
            
        </function-prolog>
        <function-map-args>
            <function-required-arg name="parameters">
                param hash
            </function-required-arg>
        </function-map-args>

        <sequence>
            <log level = "'info'">'download(%s)'%parameters</log>
            <script>
                missing = []
                for p in ['host', 'uri', 'dest', 'options']:
                  if p in parameters.keys():
                    continue
                  missing.append(p)
            </script>
            <if expr="len(missing) != 0">
                <return>[STAFRC.DoesNotExist, 'driver download missing arg(s) %s.'%[','].join(missing)]</return>
            </if>
            <script>
            	import os
                theFile = os.path.basename(parameters['uri'][0])
                if parameters['uri'][0].startswith('http'):
                  cmd = 'wget'
                  opt = '--no-proxy -O '
                else:
                  cmd = 'scp'
                  opt = ''
                cmd += ' ' + parameters['options'][0]
                cmd += ' ' + parameters['uri'][0] 
                cmd += ' ' + opt + os.path.join(parameters['dest'][0], theFile)
            </script>
            <process name="'run ' + cmd + ' - ' + parameters['host'][0]">
                <location>parameters['host'][0]</location>
                <command mode="'shell'">cmd</command>
                <workdir>parameters['dest'][0]</workdir>
                <stdout mode="'append'">outputFile[0]</stdout>
                <stderr mode="'stdout'"/>
            </process>
            <log>'"%s": RC=%s,res=%s.'%(cmd, RC, STAXResult)</log>
            <return>[RC, STAXResult]</return>
        </sequence>
    </function>
    
    <function name="getTestPlans" scope="local">
        <function-prolog>
            
        </function-prolog>
        <function-list-args>
            <function-required-arg name="plan">
                Test -plan
            </function-required-arg>
            <function-required-arg name="stage">
                [pre|post][install|upgrade]
            </function-required-arg>
        </function-list-args>

        <sequence>
            <log level = "'info'">'%s(%s, %s)'%('getTestPlan', plan, stage)</log>
            <if expr="stage not in ['postInstall', 'preUpgrade', 'postUpgrade']">
                <sequence>
                    <log>'getTestPlan - Invalid stage %s'%plug</log>
                    <return>[STAFRC.DoesNotExist, 'No such stage - %s'%plug]</return>
                </sequence>
            </if>
            <call function="'parseXML'">plan</call>
            <script>
                document = STAXResult
                allAreas = ['platform', 'common', 'smoke']
                areas = []
                node = document.getElementsByTagName("tests")
                if node.getLength() == 1:
                  all = node.item(0).getElementsByTagName("option")
                  for i in range(all.getLength()):
                    crt = all.item(i)
                    if crt.getAttributes().getNamedItem('name').getNodeValue() == 'areas':
                      areas += re.split(',\s*', crt.getFirstChild().getNodeValue().strip())
            </script>
            <log>'areas=%s.'%areas</log>
            <if expr="len(areas) == 0">
                <sequence>
                    <log>'getTestPlan - No %s test areas defined, use smoke'%stage</log>
                    <!--return>[STAFRC.Ok, 'No %s test areas defined'%stage]</return-->
                    <script>
                        areas = ['smoke']
                    </script>
                </sequence>
            </if>
            <if expr="filter(lambda x:x not in allAreas,areas) != []">
                <return>[STAFRC.DoesNotExist, 'No such test area(s) - [%s].'%','.join(filter(lambda x:x not in allAreas,areas))]</return>
            </if>
            <script>
                if stage == 'postInstall':
                  prefix = 'install'
                elif stage == 'preUpgrade':
                  prefix = 'preupgrade'
                else:
                  prefix = 'postupgrade'
                if 'smoke' in areas:
                  plan = [prefix]
                else:
                  plan = []
                  for area in areas:
                    plan.append(prefix + area)
            </script>
            <log> 'plan=%s.'%plan</log>
            <return>[STAFRC.Ok, plan]</return>
        </sequence>
    </function>
    
    <function name="setupZimbraSyslog" scope="local">
        <function-prolog>
            
        </function-prolog>
        <function-list-args>
            <function-required-arg name="machine">
                fqdn hostname
            </function-required-arg>
        </function-list-args>

        <sequence>
            <!--#####################################################
                #                                                   #
                # zmsyslogsetup has been moved to libexec in 6.0.7+ #
                #                                                   #
                #####################################################-->
            <iterate var="path" in="['libexec', 'bin']">
                <sequence>
                    <process name="'zmsyslogsetup - ' + machine">
                        <location>machine</location>
                        <command mode="'shell'">'/opt/zimbra/%s/zmsyslogsetup'%path</command>
                        <workdir>'/opt/zimbra'</workdir>
                        <stdout mode="'append'">outputFile[0]</stdout>
                        <stderr mode="'stdout'"/>
                    </process>
                    <log>'r=%s, res=%s.'%(RC, STAXResult)</log>
                    <if expr="RC == 0">
                        <break/>
                    </if>
                </sequence>
            </iterate>
            <if expr="RC != 0">
                <if expr="type(RC) == types.LongType">
                    <return>[RC, '%s - zmsyslogsetup failed, see log file for details'%machine]</return>
                    <else>
                        <return>[RC, STAFResult]</return>
                    </else>
                </if>
            </if>
            <return>[RC, '%s - zmsyslogsetup complete.'%machine]</return>
        </sequence>
    </function>
     
</stax>


